using Core
using MathOptInterface
using StaticArraysCore
#using Zlib_jll
using SuiteSparse
using Random
using PMPC
using OpenSpecFun_jll
using JuMP
using MosekTools
using IterTools
using REPL
using AMD
using LinearAlgebra
using OSQP
using OSQP_jll
using COSMO
using OrderedCollections
using PyCall
using JLLWrappers
using SparseArrays
using ECOS_jll
using DocStringExtensions
using Infiltrator
using Artifacts
#using CompilerSupportLibraries_jll
using Parsers
using ECOS
using Mosek
#using _PyJuliaHelper
#using _jll
using Requires
using Printf
using OpenLibm_jll
using MutableArithmetics
precompile(Tuple{Type{Base.Multimedia.TextDisplay}, Base.PipeEndpoint})
precompile(Tuple{Type{REPL.Terminals.TTYTerminal}, String, Base.PipeEndpoint, Base.PipeEndpoint, Base.PipeEndpoint})
precompile(Tuple{typeof(Base.something), Nothing, Base.PipeEndpoint})
precompile(Tuple{typeof(Parsers.__init__)})
precompile(Tuple{typeof(Base.resize!), Array{Base.GMP.BigInt, 1}, Int64})
precompile(Tuple{typeof(Base.resize!), Array{Base.MPFR.BigFloat, 1}, Int64})
precompile(Tuple{typeof(Base.close), Base.IOStream})
precompile(Tuple{typeof(PyCall._set_finalized)})
precompile(Tuple{typeof(Base.uv_return_spawn), Ptr{Nothing}, Int64, Int32})
precompile(Tuple{typeof(PyCall.pyjlwrap_dealloc), Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyjlwrap_repr), Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyjlwrap_hash), Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyjlwrap_hash32), Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyjlwrap_call), Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyjlwrap_getattr), Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyjlwrap_getiter), Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.__init__)})
precompile(Tuple{typeof(Base.convert), Type{PyCall.PyObject}, PyCall.PyObject})
precompile(Tuple{typeof(Base.getproperty), PyCall.PyError, Symbol})
precompile(Tuple{typeof(Base.unsafe_load), Ptr{Ptr{PyCall.PyObject_struct}}})
precompile(Tuple{typeof(PyCall.pyisinstance), PyCall.PyObject, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.current_python)})
precompile(Tuple{typeof(Base.escape_string), String})
precompile(Tuple{Type{PyCall.PyError}, String, PyCall.PyError})
precompile(Tuple{typeof(Base.convert), Type{PyCall.PyObject}, Function})
precompile(Tuple{typeof(Base.convert), Type{PyCall.PyObject}, Bool})
precompile(Tuple{typeof(Base.convert), Type{PyCall.PyObject}, Nothing})
precompile(Tuple{typeof(PyCall._pyjlwrap_call), Function, Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.typetuple), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#36#37"{PyCall.PyObject}}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#36#37"{PyCall.PyObject}}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#36#37"{PyCall.PyObject}}, Int64})
precompile(Tuple{typeof(Base.convert), Type{Tuple{String}}, PyCall.PyObject})
precompile(Tuple{typeof(Base.MainInclude.include), String})
precompile(Tuple{typeof(PyCall.pydecref), PyCall.PyObject})
precompile(Tuple{typeof(PyCall.pydecref), PyCall.PyBuffer})
precompile(Tuple{typeof(Base.require), Base.PkgId})
precompile(Tuple{Type{Base.Dict{Symbol, Any}}, Pair{Symbol, String}, Vararg{Pair{A, B} where B where A}})
precompile(Tuple{typeof(Base.Docs.doc!), Module, Base.Docs.Binding, Base.Docs.DocStr, Any})
precompile(Tuple{Type{Ref{IO}}})
precompile(Tuple{Type{Ref{Base.PipeEndpoint}}})
#precompile(Tuple{typeof(_PyJuliaHelper.IOPiper.__init__)})
precompile(Tuple{typeof(Base.setindex!), Base.RefValue{IO}, Base.PipeEndpoint})
precompile(Tuple{typeof(PyCall.pyreturn), Module})
precompile(Tuple{typeof(Base.require), Module, Symbol})
precompile(Tuple{typeof(Base.is_root_module), Module})
precompile(Tuple{typeof(Base.show), Base.IOContext{Base.GenericIOBuffer{Array{UInt8, 1}}}, Type})
precompile(Tuple{Type{NamedTuple{(:stderr, :stdout), T} where T<:Tuple}, Tuple{Base.PipeEndpoint, Base.PipeEndpoint}})
precompile(Tuple{Base.var"#pipeline##kw", NamedTuple{(:stderr, :stdout), Tuple{Base.PipeEndpoint, Base.PipeEndpoint}}, typeof(Base.pipeline), Base.Cmd})
precompile(Tuple{typeof(Base.open), Base.CmdRedirect, String, Base.PipeEndpoint})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Base.PipeEndpoint, Bool}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Base.PipeEndpoint, Bool}, Int64, Int64})
precompile(Tuple{typeof(Base.setindex!), Array{Union{Base.Libc.RawFD, IO}, 1}, Base.PipeEndpoint, Int64})
precompile(Tuple{typeof(Base.rawhandle), Base.PipeEndpoint})
precompile(Tuple{typeof(Base.uv_writecb_task), Ptr{Nothing}, Int32})
precompile(Tuple{typeof(Base.write), Base.PipeEndpoint, String})
precompile(Tuple{typeof(Base.close), Base.PipeEndpoint})
precompile(Tuple{typeof(Base._uv_hook_close), Base.PipeEndpoint})
precompile(Tuple{typeof(OSQP_jll.__init__)})
precompile(Tuple{typeof(OSQP_jll.find_artifact_dir)})
precompile(Tuple{typeof(PyCall.pyany_toany), Type})
precompile(Tuple{typeof(Base.uvfinalize), Base.PipeEndpoint})
precompile(Tuple{typeof(Artifacts._artifact_str), Module, String, Base.SubString{String}, String, Base.Dict{String, Any}, Base.SHA1, Base.BinaryPlatforms.Platform, Any})
precompile(Tuple{typeof(Base.invokelatest), Any})
precompile(Tuple{typeof(JLLWrappers.get_julia_libpaths)})
precompile(Tuple{typeof(OpenLibm_jll.__init__)})
precompile(Tuple{typeof(DocStringExtensions.__init__)})
#precompile(Tuple{typeof(CompilerSupportLibraries_jll.__init__)})
precompile(Tuple{typeof(OpenSpecFun_jll.__init__)})
precompile(Tuple{typeof(OpenSpecFun_jll.find_artifact_dir)})
#precompile(Tuple{typeof(Bzip2_jll.__init__)})
#precompile(Tuple{typeof(Bzip2_jll.find_artifact_dir)})
#precompile(Tuple{typeof(Zlib_jll.__init__)})
precompile(Tuple{typeof(ECOS_jll.__init__)})
precompile(Tuple{typeof(ECOS_jll.find_artifact_dir)})
precompile(Tuple{typeof(ECOS.__init__)})
precompile(Tuple{typeof(Mosek.__init__)})
precompile(Tuple{typeof(AMD.__init__)})
precompile(Tuple{typeof(Base.Libc.Libdl.dlsym), Ptr{Nothing}, String})
precompile(Tuple{typeof(Requires.__init__)})
precompile(Tuple{typeof(Requires.loadpkg), Base.PkgId})
precompile(Tuple{typeof(COSMO.__init__)})
precompile(Tuple{typeof(Requires.isprecompiling)})
precompile(Tuple{typeof(Requires.listenpkg), Any, Base.PkgId})
precompile(Tuple{typeof(Requires.loaded), Base.PkgId})
precompile(Tuple{typeof(Requires.callbacks), Base.PkgId})
precompile(Tuple{typeof(Infiltrator.__init__)})
precompile(Tuple{typeof(PyCall.pyjlwrap_call), Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall._pyjlwrap_call), Function, Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N}}, PyCall.PyObject})
precompile(Tuple{typeof(Base.length), Core.SimpleVector})
precompile(Tuple{typeof(PyCall.pyo2ptr), Type})
precompile(Tuple{typeof(JuMP.Containers._broadcast_axes_check), Tuple{}})
precompile(Tuple{typeof(Base.convert), Type{Array{Float64, N} where N}, PyCall.PyObject})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#9#10"{PyCall.PyBuffer}}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#9#10"{PyCall.PyBuffer}}, Int64})
precompile(Tuple{Type{PyCall.PyArray_Info{Float64, 2}}, Bool, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Ptr{Nothing}, Bool, PyCall.PyBuffer})
precompile(Tuple{Type{PyCall.PyArray{Float64, 2}}, PyCall.PyObject, PyCall.PyArray_Info{Float64, 2}})
precompile(Tuple{typeof(PyCall.pyocopy), PyCall.PyArray{Float64, 2}})
precompile(Tuple{Type{PyCall.PyArray_Info{Float64, 3}}, Bool, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Ptr{Nothing}, Bool, PyCall.PyBuffer})
precompile(Tuple{Type{PyCall.PyArray{Float64, 3}}, PyCall.PyObject, PyCall.PyArray_Info{Float64, 3}})
precompile(Tuple{typeof(PyCall.pyocopy), PyCall.PyArray{Float64, 3}})
precompile(Tuple{Type{PyCall.PyArray_Info{Float64, 4}}, Bool, Tuple{Int64, Int64, Int64, Int64}, Tuple{Int64, Int64, Int64, Int64}, Ptr{Nothing}, Bool, PyCall.PyBuffer})
precompile(Tuple{Type{PyCall.PyArray{Float64, 4}}, PyCall.PyObject, PyCall.PyArray_Info{Float64, 4}})
precompile(Tuple{Type{Base.IteratorsMD.CartesianIndex{N} where N}, Tuple{Int64, Int64, Int64, Int64}})
precompile(Tuple{typeof(Base.tail), Tuple{Int64, Int64, Int64, Int64}})
precompile(Tuple{typeof(Base.tail), Tuple{Int64, Int64, Int64}})
precompile(Tuple{typeof(PyCall.pyocopy), PyCall.PyArray{Float64, 4}})
precompile(Tuple{Type{PyCall.PyDict{Symbol, PyCall.PyObject, true}}, PyCall.PyObject})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}, PyCall.PyDict{Symbol, PyCall.PyObject, true}})
precompile(Tuple{typeof(Base.collect), Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ref{Int64}}, Base.RefValue{Int64}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ref{Ptr{PyCall.PyObject_struct}}}, Base.RefValue{Ptr{PyCall.PyObject_struct}}})
precompile(Tuple{typeof(Base.convert), Type{Float64}, PyCall.PyObject})
precompile(Tuple{typeof(Base._array_for), Type{Tuple{Symbol, Float64}}, Base.HasLength, Int64})
precompile(Tuple{typeof(Base.ndims), Array{Tuple{Symbol, Float64}, 1}})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Tuple{Symbol, Float64}, 1}, Tuple{Symbol, Float64}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}}, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.setindex_widen_up_to), Array{Tuple{Symbol, Float64}, 1}, Tuple{Symbol, Array{Float64, 3}}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Tuple{Symbol, Any}, 1}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}}, Int64, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, Array{Tuple{Symbol, Any}, 1}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), T} where T<:Tuple}, Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}})
precompile(Tuple{typeof(Base._compute_eltype), Any})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{Base.var"#invokelatest##kw", NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{Base.var"##invokelatest#2", Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{typeof(Base.tail), Tuple{Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{typeof(Base.:(<)), Int64})
precompile(Tuple{Type{NamedTuple{(:outer,), T} where T<:Tuple}, Tuple{Tuple{Int64}}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:outer,), Tuple{Tuple{Int64}}}, Symbol})
precompile(Tuple{typeof(Base._RepeatInnerOuter.to_tuple), Tuple{Int64}})
precompile(Tuple{typeof(Base.fill_to_length), Tuple{Int64}, Int64, Base.Val{1}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Nothing, 1}}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{StaticArraysCore.Dynamic, 1}}})
precompile(Tuple{Type{StaticArraysCore.Size{S} where S}, Tuple{StaticArraysCore.Dynamic}})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Type{Nothing}})
precompile(Tuple{typeof(Base.Broadcast.combine_styles), Nothing})
precompile(Tuple{typeof(Base.axes), Nothing})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(Base.eltype), typeof(Base.promote_type)}, Type{Array{Float64, 1}}})
precompile(Tuple{typeof(Base.reduce_first), Function, Type})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(Base.eltype), typeof(Base.promote_type)}, Type{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{Base.var"#146#148", typeof(Base.add_sum)}, Type{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base._tuple_any), typeof(Base.has_offset_axes), Bool, Function})
precompile(Tuple{typeof(Base.:(+)), Int64, Float64})
precompile(Tuple{typeof(Base.:(-)), Int64, Float64})
precompile(Tuple{typeof(Base.:(-)), LinearAlgebra.UniformScaling{Bool}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:dims,), Tuple{Base.Val{2}}}, Symbol})
precompile(Tuple{typeof(Base.tail), Tuple{Bool, Bool}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, Base.var"#97#98"{typeof(Base.iszero)}, Tuple{Bool, Bool}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Tuple{Bool, Bool}, Base.var"#97#98"{typeof(Base.iszero)}}})
precompile(Tuple{Base.var"#97#98"{typeof(Base.iszero)}, Bool})
precompile(Tuple{typeof(Base.ntuple), Base.Returns{Base.OneTo{Int64}}, Base.Val{1}})
precompile(Tuple{Type{Signed}, UInt64})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Base.Broadcast.DefaultArrayStyle{0}, SparseArrays.HigherOrderFns.SparseVecStyle})
precompile(Tuple{SparseArrays.HigherOrderFns.var"#21#24", Float64})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(Base.adjoint), Float64})
precompile(Tuple{typeof(Base.iterate), Int64})
precompile(Tuple{typeof(Base.Iterators.zip), Int64, Int64})
precompile(Tuple{typeof(Base.tail), Tuple{Tuple{Int64, Nothing}, Tuple{Int64, Nothing}}})
precompile(Tuple{typeof(Base.zero), Type{Any}})
precompile(Tuple{typeof(Base.reduce_empty), typeof(Base.:(+)), Type{Any}})
precompile(Tuple{typeof(Base.reduce_empty), typeof(Base.add_sum), Type{Any}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(Base.identity), typeof(Base.add_sum)}, Type{Any}})
precompile(Tuple{typeof(Base.promote_result), Type, Type, Type{Union{Nothing, Float64}}, Type{Union{}}})
precompile(Tuple{typeof(Base.ntuple), Base.Returns{Int64}, Base.Val{1}})
precompile(Tuple{typeof(Base._cshp), Int64, Tuple{Bool, Bool}, Tuple{}, Tuple{Int64}})
precompile(Tuple{typeof(Base._cshp), Int64, Tuple{Bool}, Tuple{Int64}, Tuple{}})
precompile(Tuple{typeof(Base.iszero), Nothing})
precompile(Tuple{Base.var"#97#98"{typeof(Base.iszero)}, Nothing})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Float64, 1}}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Real, 1}}})
precompile(Tuple{Type{Ptr{ECOS.pwork}}, Int64})
precompile(Tuple{Type{COSMO.ZeroSet{Float64}}, Int64})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{COSMO.var"#18#20", typeof(Base.add_sum)}, Type{COSMO.ZeroSet{Float64}}})
precompile(Tuple{Type{NamedTuple{(:mem,), T} where T<:Tuple}, Tuple{Int64}})
precompile(Tuple{COSMO.var"#with_options##kw", NamedTuple{(:mem,), Tuple{Int64}}, typeof(COSMO.with_options), Type})
precompile(Tuple{Type{COSMO.OptionsFactory{COSMOAccelerators.AndersonAccelerator{Float64, COSMOAccelerators.Type2{COSMOAccelerators.QRDecomp}, COSMOAccelerators.RestartedMemory, COSMOAccelerators.NoRegularizer}}}, Type, Tuple{}, Base.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:mem,), Tuple{Int64}}}})
precompile(Tuple{Type{COSMO.OptionsFactory{COSMO.CliqueGraphMerge}}, Type, Tuple{}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}})
precompile(Tuple{COSMO.var"##with_options#112", Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, typeof(COSMO.with_options), Type})
precompile(Tuple{typeof(COSMO.with_options), Type})
precompile(Tuple{Type{COSMO.OptionsFactory{COSMO.QdldlKKTSolver{Tv, Ti} where Ti where Tv}}, Type, Tuple{}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}})
precompile(Tuple{Type{NamedTuple{(:logical,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:logical,), Tuple{Bool}}, Symbol})
precompile(Tuple{typeof(Base.reduce_empty), Base.BottomRF{typeof(Base.min)}, Type{Int64}})
precompile(Tuple{Type{NamedTuple{(:by, :rev), T} where T<:Tuple}, Tuple{COSMO.var"#86#88", Bool}})
precompile(Tuple{Type{Base.Order.By{COSMO.var"#86#88", Base.Order.ForwardOrdering}}, Function, Base.Order.ForwardOrdering})
precompile(Tuple{Type{Base.Order.By{COSMO.var"#86#88", Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}}, Function, Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:by, :rev), Tuple{COSMO.var"#86#88", Bool}}, Symbol})
precompile(Tuple{typeof(IterTools.pop), Tuple{Int64, Int64}})
precompile(Tuple{Type{DomainError}, Any})
precompile(Tuple{Type{Base.BottomRF{typeof(Base._rf_findmax)}}, Function})
precompile(Tuple{typeof(Base.convert), Type{Base.Fix1{Type{Base.MappingRF{F, T} where T where F}, Base.var"#277#278"{typeof(Base.identity)}}}, Base.Fix1{Type{Base.MappingRF{F, T} where T where F}, Base.var"#277#278"{typeof(Base.identity)}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{Base.var"#277#278"{typeof(Base.identity)}, Base.BottomRF{typeof(Base._rf_findmax)}}, Type{Pair{Int64, Float64}}})
precompile(Tuple{Type{NamedTuple{(:alg, :rev), T} where T<:Tuple}, Tuple{Base.Sort.QuickSortAlg, Bool}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:alg, :rev), Tuple{Base.Sort.QuickSortAlg, Bool}}, Symbol})
precompile(Tuple{typeof(Base.convert), Type{Base.Fix1{Type{Base.MappingRF{F, T} where T where F}, Base.var"#146#148"}}, Base.Fix1{Type{Base.MappingRF{F, T} where T where F}, Base.var"#146#148"}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:lt,), Tuple{typeof(Base.:(<=))}}, Symbol})
precompile(Tuple{Type{Base.Order.Lt{Base.Order.var"#1#3"{typeof(Base.:(<=)), typeof(Base.identity)}}}, Function})
precompile(Tuple{typeof(Base._tuple_any), Function, Tuple{}})
precompile(Tuple{typeof(Base.rem), UInt16, Type{UInt32}})
precompile(Tuple{typeof(Base.:(<=)), UInt8, UInt64})
precompile(Tuple{typeof(Base.convert), Type{Type{Pair{A, B} where B where A}}, Type{Pair{A, B} where B where A}})
precompile(Tuple{typeof(Base.:(<)), UInt32, Int64})
precompile(Tuple{typeof(Base.contains), String})
precompile(Tuple{typeof(Base.reverse), Tuple{Int64}})
precompile(Tuple{typeof(Base.cconvert), Type{Ptr{PyCall.PyObject_struct}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{PyCall.PyObject_struct}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.promote_result), Type, Type, Type{Any}, Type{Union{}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{COSMO.var"#18#20", typeof(Base.add_sum)}, Type{COSMO.AbstractConvexSet{Float64}}})
precompile(Tuple{Type{BoundsError}, Any})
precompile(Tuple{typeof(Base.:(*)), Float64, LinearAlgebra.UniformScaling{Bool}})
precompile(Tuple{typeof(Base.Broadcast.broadcastable), Float64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Nothing, typeof(Base.identity), Tuple{Float64}}}, Function, Tuple{Float64}, Nothing})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Float64}}, Tuple{Float64}})
precompile(Tuple{typeof(Base.getindex), Float64})
precompile(Tuple{Type{NamedTuple{(:reset,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(LinearAlgebra.norm), Float64})
precompile(Tuple{typeof(Base.float), Float64})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(LinearAlgebra.norm), typeof(Base.max)}, Type{Float64}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{Base.ComposedFunction{typeof(Base.float), typeof(LinearAlgebra.norm)}, typeof(Base.:(+))}, Type{Float64}})
precompile(Tuple{typeof(Base.argtail), Function, Function, Vararg{Any}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(LinearAlgebra.norm), typeof(Base.min)}, Type{Float64}})
precompile(Tuple{typeof(Base.:(==)), Float64, Int64})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:reset,), Tuple{Bool}}, Symbol})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(Base.one), Type})
precompile(Tuple{typeof(Base.Broadcast.extrude), Float64})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex), Float64, Int64})
precompile(Tuple{Type{Base.DimensionMismatch}})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Base.Broadcast.DefaultArrayStyle{0}, SparseArrays.HigherOrderFns.SparseMatStyle})
precompile(Tuple{typeof(Base.iszero), Bool})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:dims,), Tuple{Base.Colon}}, Symbol})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex), Float64, Base.IteratorsMD.CartesianIndex{0}})
precompile(Tuple{Base.var"#97#98"{typeof(Base.iszero)}, Float64})
precompile(Tuple{Type{Base.Pairs{Symbol, V, I, A} where A where I where V}, NamedTuple{(:by,), Tuple{COSMO.var"#137#138"}}, Tuple{Symbol}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:by,), Tuple{COSMO.var"#137#138"}}, Symbol})
precompile(Tuple{Type{Base.Order.By{COSMO.var"#137#138", Base.Order.ForwardOrdering}}, Function, Base.Order.ForwardOrdering})
precompile(Tuple{Type{NamedTuple{(:tab,), T} where T<:Tuple}, Tuple{Int64}})
precompile(Tuple{typeof(Base.convert), Type{Base.Broadcast.var"#41#42"{Base.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:digits,), Tuple{Int64}}}, typeof(Base.round)}}, Base.Broadcast.var"#41#42"{Base.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:digits,), Tuple{Int64}}}, typeof(Base.round)}})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(Base.zero), Type})
precompile(Tuple{typeof(Base.Broadcast._getindex), Tuple{Int64}, Base.IteratorsMD.CartesianIndex{0}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Nothing, Type{Float64}, Tuple{Int64}}}, Type, Tuple{Int64}, Nothing})
precompile(Tuple{typeof(Base.Broadcast.broadcastable), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Nothing, Type{Float64}, Tuple{Int64}}})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Nothing, Type{Float64}, Tuple{Int64}}, Int64})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), Type{Float64}, Int64})
precompile(Tuple{typeof(Base.promote), Bool, Bool, Float64})
precompile(Tuple{typeof(Base.:(!=)), Char, Char})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:perm,), Tuple{Nothing}}, Symbol})
precompile(Tuple{Type{Float32}, Float32})
precompile(Tuple{typeof(Base.:(/)), Float64, Int64})
precompile(Tuple{typeof(Base.:(*)), Float64, Float64})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{Base.ComposedFunction{typeof(Base.float), typeof(LinearAlgebra.norm)}, typeof(Base.:(+))}, Type{Any}})
precompile(Tuple{typeof(Printf.base), Type})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(Base.:(-)), Float64})
precompile(Tuple{typeof(LinearAlgebra.dot), Float64, Float64})
precompile(Tuple{typeof(LinearAlgebra.throw_uplo)})
precompile(Tuple{typeof(LinearAlgebra.char_uplo), Symbol})
precompile(Tuple{Type{NamedTuple{(:check,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:check,), Tuple{Bool}}, Symbol})
precompile(Tuple{typeof(Base.sqrt), Int64})
precompile(Tuple{Base.Iterators.var"#9#10"{Tuple{Array{Base.SubArray{Float64, 1, Array{Float64, 1}, Tuple{Base.UnitRange{Int64}}, true}, 1}, Array{COSMO.AbstractConvexSet{T} where T, 1}}}, Int64})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Base.HasEltype, 1}}})
precompile(Tuple{Base.Iterators.var"#1#2"{Tuple{Array{Base.SubArray{Float64, 1, Array{Float64, 1}, Tuple{Base.UnitRange{Int64}}, true}, 1}, Array{COSMO.AbstractConvexSet{T} where T, 1}}}, Int64})
precompile(Tuple{typeof(Base.identity), Float64})
precompile(Tuple{typeof(Base.add_sum), Float64, Float64})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Base.OneTo{Int64}, 1}}})
precompile(Tuple{typeof(Base.copysign), Float64, Float64})
precompile(Tuple{Type{NamedTuple{(:modifier,), T} where T<:Tuple}, Tuple{String}})
precompile(Tuple{Type{NamedTuple{(:modifier,), Tuple{String}}}, Tuple{String}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:modifier,), Tuple{String}}, Symbol})
precompile(Tuple{typeof(Core.toUInt16), Int64})
precompile(Tuple{typeof(COSMO.free_memory!), Nothing})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(), Tuple{}}, Symbol})
precompile(Tuple{Type{Pair{A, B} where B where A}, String, Bool})
precompile(Tuple{Core.Compiler.var"#273#274", Any})
precompile(Tuple{Type{NamedTuple{(:with_bridge_type,), T} where T<:Tuple}, Tuple{DataType}})
precompile(Tuple{typeof(Base.convert), Type{MathOptInterface.Utilities.CachingOptimizerState}, MathOptInterface.Utilities.CachingOptimizerState})
precompile(Tuple{typeof(Base.convert), Type{MathOptInterface.Utilities.CachingOptimizerMode}, MathOptInterface.Utilities.CachingOptimizerMode})
precompile(Tuple{Type{NamedTuple{(:add_bridges,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(JuMP.build_variable), Function, JuMP.VariableInfo{Float64, Float64, Float64, Float64}})
precompile(Tuple{typeof(MutableArithmetics.mutability), Type})
precompile(Tuple{typeof(JuMP._throw_error_for_invalid_sense), Function, MathOptInterface.OptimizationSense})
precompile(Tuple{typeof(Base.maybeview), Nothing, Function, Int64})
precompile(Tuple{typeof(Base.maybeview), Nothing, Function, Function, Vararg{Any}})
precompile(Tuple{typeof(Base.tail), Tuple{Base.Colon, Int64}})
precompile(Tuple{PMPC.var"#lcone_solve##kw", NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}, typeof(PMPC.lcone_solve), Array{Float64, 2}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}})
precompile(Tuple{Type{Pair{A, B} where B where A}, Symbol, Float64})
precompile(Tuple{Type{Pair{A, B} where B where A}, Symbol, Array{Float64, 3}})
precompile(Tuple{PMPC.var"#84#89", Array{Float64, 3}})
precompile(Tuple{typeof(Base.map), PMPC.var"#84#89", Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}})
precompile(Tuple{typeof(Base.size), Float64})
precompile(Tuple{typeof(Base.:(==)), Tuple{}, Tuple{}})
precompile(Tuple{typeof(Base.repeat), Array{Float64, 1}, Int64})
precompile(Tuple{typeof(Base.:(!=)), Array{Float64, 3}, Nothing})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 3}, Function, Function, Vararg{Any}})
precompile(Tuple{typeof(Base.view), Array{Float64, 3}, Function, Function, Int64})
precompile(Tuple{typeof(Base.to_indices), Array{Float64, 3}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, Tuple{Base.Colon, Base.Colon, Int64}})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 1}, Int64})
precompile(Tuple{typeof(Base.:(!=)), Array{Float64, 1}, Nothing})
precompile(Tuple{typeof(Base.:(!=)), Array{Float64, 2}, Nothing})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 2}, Function, Int64})
precompile(Tuple{Type{NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :smooth_alpha, :slew_um1, :ux, :uu, :slew_reg, :smooth_cstr), T} where T<:Tuple}, Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, String}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :smooth_alpha, :slew_um1, :ux, :uu, :slew_reg, :smooth_cstr), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, String}}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :smooth_alpha, :slew_um1, :ux, :uu, :slew_reg, :smooth_cstr), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, String}}})
precompile(Tuple{typeof(Base.afoldl), Base.var"#49#50", Type, Type, Type, Type, Type})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{PMPC.var"#make_prob##kw", NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :smooth_alpha, :slew_um1, :ux, :uu, :slew_reg, :smooth_cstr), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, String}}, typeof(PMPC.make_prob), Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{PMPC.var"#7#8", Nothing})
precompile(Tuple{typeof(Base.map), PMPC.var"#7#8", Tuple{Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}}})
precompile(Tuple{Type{PMPC.OCProb{Float64}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Float64, Float64, Float64, Nothing, Float64, Int64, Int64, Int64})
precompile(Tuple{typeof(Base.setproperty!), PMPC.OCProb{Float64}, Symbol, Float64})
precompile(Tuple{typeof(Base.setproperty!), PMPC.OCProb{Float64}, Symbol, Array{Float64, 1}})
precompile(Tuple{typeof(Base.convert), Type{Union{Nothing, AbstractArray{Float64, 1}}}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.:(!=)), Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing})
precompile(Tuple{typeof(PMPC.set_ubounds!), PMPC.OCProb{Float64}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{Type{NamedTuple{(:slew_reg0, :slew_um1, :slew_reg), T} where T<:Tuple}, Tuple{Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}})
precompile(Tuple{PMPC.var"#set_ctrl_slew!##kw", NamedTuple{(:slew_reg0, :slew_um1, :slew_reg), Tuple{Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}}, typeof(PMPC.set_ctrl_slew!), PMPC.OCProb{Float64}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, PMPC.var"#106#108", Base.Dict{Any, Any}})
precompile(Tuple{Type{Base.Dict{Symbol, Any}}, Base.Generator{Base.Dict{Any, Any}, PMPC.var"#106#108"}})
precompile(Tuple{typeof(PMPC.lcone_repr_Pq), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{Type{NamedTuple{(:shift, :check), T} where T<:Tuple}, Tuple{Float64, Bool}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:shift, :check), Tuple{Float64, Bool}}, Symbol})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{8}})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{10}})
precompile(Tuple{typeof(SparseArrays.HigherOrderFns._capturescalars), Float64})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Base.Broadcast.DefaultArrayStyle{0}, SparseArrays.HigherOrderFns.PromoteToSparse})
precompile(Tuple{typeof(SparseArrays.HigherOrderFns._sparsifystructured), Float64})
precompile(Tuple{typeof(Base.:(==)), Function, Function})
precompile(Tuple{typeof(Base.iszero), Float64})
precompile(Tuple{typeof(Base.adjoint), Float64})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Base.Broadcast.DefaultArrayStyle{1}, SparseArrays.HigherOrderFns.SparseVecStyle})
precompile(Tuple{typeof(Base.:(\)), Float64, Float64})
precompile(Tuple{typeof(Base.pairs), NamedTuple{(:check,), Tuple{Bool}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:check,), Tuple{Bool}}}})
precompile(Tuple{Type{LinearAlgebra.SingularException}, Int64})
precompile(Tuple{Type{SuiteSparse.UMFPACK.MatrixIllConditionedException}, String})
precompile(Tuple{typeof(Base.cconvert), Type{Ptr{Int64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{Int64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.cconvert), Type{Ptr{Float64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{Float64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.convert), Type{Ptr{SuiteSparse.LibSuiteSparse.cholmod_dense_struct}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.abs2), Float64})
precompile(Tuple{typeof(Base.mapreduce_empty), typeof(Base.abs2), Function, Type})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{typeof(Base.task_done_hook), Task})
precompile(Tuple{typeof(Base.task_done_hook), Task})
precompile(Tuple{typeof(Base.task_done_hook), Task})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#407#threadsfor_fun#72"{PMPC.var"#407#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{typeof(Base.task_done_hook), Task})
precompile(Tuple{typeof(Base.task_done_hook), Task})
precompile(Tuple{typeof(Base.getindex), Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Int64, Int64, Int64})
precompile(Tuple{typeof(Base.task_done_hook), Task})
precompile(Tuple{typeof(Base.setindex!), Array{Float64, 1}, Float64, Int64})
precompile(Tuple{typeof(Base.:(*)), Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(+)), Tuple{Array{Float64, 1}, Array{Float64, 1}}})
precompile(Tuple{typeof(Base.Broadcast.materialize!), Base.SubArray{Float64, 1, Array{Float64, 1}, Tuple{Base.UnitRange{Int64}}, true}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(Base.:(+)), Tuple{Array{Float64, 1}, Array{Float64, 1}}}})
precompile(Tuple{typeof(Base.getindex), Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Int64, Int64})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Float64, Base.Val{2}})
precompile(Tuple{typeof(Base.:(*)), Float64, Float64, Float64})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_allocate_sparse), Int64, Int64, Int64, Bool, Bool, Int64, Int64, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_check_sparse), SuiteSparse.CHOLMOD.Sparse{Float64}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_symmetry), SuiteSparse.CHOLMOD.Sparse{Float64}, Int64, Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(Base.getproperty), SuiteSparse.LibSuiteSparse.cholmod_common_struct, Symbol})
precompile(Tuple{typeof(Base.setproperty!), SuiteSparse.LibSuiteSparse.cholmod_common_struct, Symbol, Bool})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_analyze), SuiteSparse.CHOLMOD.Sparse{Float64}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(Base.setproperty!), SuiteSparse.LibSuiteSparse.cholmod_common_struct, Symbol, Int32})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_factorize_p), SuiteSparse.CHOLMOD.Sparse{Float64}, Base.RefValue{Float64}, Ptr{Nothing}, Int64, SuiteSparse.CHOLMOD.Factor{Float64}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{Type{SuiteSparse.CHOLMOD.FactorComponent{Float64, :L}}, SuiteSparse.CHOLMOD.Factor{Float64}})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_copy_factor), SuiteSparse.CHOLMOD.Factor{Float64}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_factor_to_sparse), SuiteSparse.CHOLMOD.Factor{Float64}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{Type{Base.Order.Perm{O, V} where V<:(AbstractArray{T, 1} where T) where O<:Base.Order.Ordering}, Base.Order.ForwardOrdering, Array{Int64, 1}})
precompile(Tuple{typeof(Base.sort!), Array{Int64, 1}, Base.Sort.QuickSortAlg, Base.Order.Perm{Base.Order.ForwardOrdering, Array{Int64, 1}}})
precompile(Tuple{typeof(SparseArrays._distributevals_halfperm!), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Base.UnitRange{Int64}, SparseArrays.var"#12#13"})
precompile(Tuple{typeof(SparseArrays._sparsevector!), Array{Int64, 1}, Array{Float64, 1}, Int64, typeof(Base.:(+))})
precompile(Tuple{Base.var"##cat_t#150", Base.Val{1}, typeof(Base.cat_t), Type{Float64}, SparseArrays.SparseVector{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_t), Base.Val{1}, Type{Float64}, SparseArrays.SparseVector{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.cat_size_shape), Tuple{Bool}, SparseArrays.SparseVector{Float64, Int64}, Float64, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_size_shape), Tuple{Bool}, Tuple{Int64}, Float64, SparseArrays.SparseVector{Float64, Int64}})
precompile(Tuple{typeof(Base.cat_similar), SparseArrays.SparseVector{Float64, Int64}, Type, Tuple{Int64}})
precompile(Tuple{typeof(Base.similar), SparseArrays.SparseVector{Float64, Int64}, Type{Float64}, Tuple{Int64}})
precompile(Tuple{typeof(Base.__cat), SparseArrays.SparseVector{Float64, Int64}, Tuple{Int64}, Tuple{Bool}, SparseArrays.SparseVector{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseVector{Float64, Int64}, Tuple{Int64}, Tuple{Bool}, Tuple{Int64}, SparseArrays.SparseVector{Float64, Int64}, Float64, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseVector{Float64, Int64}, Tuple{Int64}, Tuple{Bool}, Tuple{Int64}, Float64, SparseArrays.SparseVector{Float64, Int64}})
precompile(Tuple{typeof(SparseArrays.blockdiag), SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#421#threadsfor_fun#74"{PMPC.var"#421#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{typeof(Base.promote_eltype), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(SparseArrays.promote_idxtype), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(PMPC.lcone_repr_Ab), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{typeof(PMPC.lcone_repr_Gla), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{typeof(Base.getindex), Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Int64})
precompile(Tuple{typeof(Base.zeros), Int64})
precompile(Tuple{typeof(Base.vcat), Array{Float64, 1}, Array{Float64, 1}, Float64})
precompile(Tuple{typeof(Base.__cat_offset!), Array{Float64, 1}, Tuple{Int64}, Tuple{Bool}, Tuple{Int64}, Array{Float64, 1}, Float64})
precompile(Tuple{typeof(Base.require_one_based_indexing), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.size), SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64})
precompile(Tuple{typeof(Base.fill), Int64, Int64})
precompile(Tuple{typeof(LinearAlgebra.promote_to_arrays), Array{Int64, 1}, Int64, Type{SparseArrays.SparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv}, SparseArrays.SparseMatrixCSC{Float64, Int64}, LinearAlgebra.UniformScaling{Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{Base.var"#cat##kw", NamedTuple{(:dims,), Tuple{Base.Val{2}}}, typeof(Base.cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{Base.var"##cat#155", Base.Val{2}, typeof(Base.cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat), Base.Val{2}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Union{Number, Array{T, 1} where T, Array{T, 2} where T, LinearAlgebra.AbstractTriangular{T, A} where A<:(Array{T, 2} where T) where T, LinearAlgebra.AbstractTriangular{T, A} where A<:Union{LinearAlgebra.Adjoint{var"#s886", var"#s885"} where var"#s885"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s886", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Transpose{var"#s884", var"#s883"} where var"#s883"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s884", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv} where T, LinearAlgebra.Adjoint{var"#s886", var"#s885"} where var"#s885"<:(Array{T, 1} where T) where var"#s886", LinearAlgebra.Adjoint{var"#s886", var"#s885"} where var"#s885"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s886", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Hermitian{T, A} where A<:(Array{T, 2} where T) where T, LinearAlgebra.Hermitian{T, A} where A<:Union{LinearAlgebra.Adjoint{var"#s886", var"#s885"} where var"#s885"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s886", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Transpose{var"#s884", var"#s883"} where var"#s883"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s884", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Symmetric{T, A} where A<:(Array{T, 2} where T) where T, LinearAlgebra.Symmetric{T, A} where A<:Union{LinearAlgebra.Adjoint{var"#s886", var"#s885"} where var"#s885"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s886", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Transpose{var"#s884", var"#s883"} where var"#s883"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s884", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv} where T, LinearAlgebra.Transpose{var"#s884", var"#s883"} where var"#s883"<:(Array{T, 1} where T) where var"#s884", LinearAlgebra.Transpose{var"#s884", var"#s883"} where var"#s883"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s884", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv}}})
precompile(Tuple{typeof(Base.argtail), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.map), typeof(SparseArrays._makesparse), Tuple{SparseArrays.SparseMatrixCSC{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.promote_eltype), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{Base.var"#cat_t##kw", NamedTuple{(:dims,), Tuple{Base.Val{2}}}, typeof(Base.cat_t), Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{Base.var"##cat_t#150", Base.Val{2}, typeof(Base.cat_t), Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_t), Base.Val{2}, Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.cat_size_shape), Tuple{Bool, Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_size_shape), Tuple{Bool, Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.cat_similar), SparseArrays.SparseMatrixCSC{Float64, Int64}, Type, Tuple{Int64, Int64}})
precompile(Tuple{typeof(Base.similar), SparseArrays.SparseMatrixCSC{Float64, Int64}, Type{Float64}, Tuple{Int64, Int64}})
precompile(Tuple{typeof(Base.__cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool, Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool, Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool, Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.length), Array{Float64, 1}})
precompile(Tuple{Type{PMPC.ConeProblem}, Int64, Array{Int64, 1}, Int64, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{Type{NamedTuple{(:method, :solver), T} where T<:Tuple}, Tuple{String, String}})
precompile(Tuple{PMPC.var"#smoothen_linear_inequlities##kw", NamedTuple{(:method, :solver), Tuple{String, String}}, typeof(PMPC.smoothen_linear_inequlities), SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Float64})
precompile(Tuple{Base.var"##cat_t#150", Base.Val{1}, typeof(Base.cat_t), Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base._cat_t), Base.Val{1}, Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.cat_size_shape), Tuple{Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base._cat_size_shape), Tuple{Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.__cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(SparseArrays.blockdiag), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(SparseArrays._blockdiag), Type{Float64}, Type{Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{Type{NamedTuple{(:extra_cstr,), T} where T<:Tuple}, Tuple{Tuple{Int64, Array{Int64, 1}, Int64, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}}}})
precompile(Tuple{typeof(Base.map), Type, Tuple{}})
precompile(Tuple{typeof(Base.promote_rule), Type{Union{Nothing, Float64}}, Type})
precompile(Tuple{typeof(SuiteSparse.CHOLMOD.free!), SuiteSparse.CHOLMOD.Sparse{Float64}})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_free_sparse), Base.RefValue{Ptr{SuiteSparse.LibSuiteSparse.cholmod_sparse_struct}}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SuiteSparse.CHOLMOD.free!), SuiteSparse.CHOLMOD.Factor{Float64}})
precompile(Tuple{typeof(SuiteSparse.LibSuiteSparse.cholmod_l_free_factor), Base.RefValue{Ptr{SuiteSparse.LibSuiteSparse.cholmod_factor_struct}}, Base.RefValue{SuiteSparse.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{PMPC.var"#augment_cone_problem!##kw", NamedTuple{(:extra_cstr,), Tuple{Tuple{Int64, Array{Int64, 1}, Int64, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}}}}, typeof(PMPC.augment_cone_problem!), PMPC.ConeProblem})
precompile(Tuple{typeof(Base.getindex), Array{Float64, 1}, Base.UnitRange{Int64}})
precompile(Tuple{typeof(Base.sum), Array{Int64, 1}})
precompile(Tuple{typeof(Base.vcat), Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.setproperty!), PMPC.ConeProblem, Symbol, Array{Float64, 1}})
precompile(Tuple{typeof(Base.copy), Array{Float64, 1}})
precompile(Tuple{typeof(Base.convert), Type{AbstractArray{Float64, 1}}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.view), Array{Float64, 1}, Base.UnitRange{Int64}})
precompile(Tuple{typeof(Base.iterate), Array{Tuple, 1}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, NamedTuple{(:verbose,), Tuple{Bool}}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:verbose,), Tuple{Bool}}})
precompile(Tuple{PMPC.var"#ECOS_solve##kw", NamedTuple{(:verbose,), Tuple{Bool}}, typeof(PMPC.ECOS_solve), PMPC.ConeProblem})
precompile(Tuple{typeof(Base._array_for), Type{Int64}, Base.HasShape{1}, Tuple{Base.OneTo{Int64}}})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Int64, 1}, Int64, Base.Generator{Array{Symbol, 1}, PMPC.var"#55#56"{PMPC.ConeProblem}}, Int64})
precompile(Tuple{typeof(Base.setindex_widen_up_to), Array{Int64, 1}, Array{Int64, 1}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Any, 1}, Base.Generator{Array{Symbol, 1}, PMPC.var"#55#56"{PMPC.ConeProblem}}, Int64, Int64})
precompile(Tuple{typeof(Base.:(!=)), SparseArrays.SparseMatrixCSC{Float64, Int64}, Nothing})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Int64, 1}, Int64, Base.Generator{Array{Symbol, 1}, PMPC.var"#50#52"{PMPC.ConeProblem}}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Any, 1}, Base.Generator{Array{Symbol, 1}, PMPC.var"#50#52"{PMPC.ConeProblem}}, Int64, Int64})
precompile(Tuple{typeof(Base.copy), SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.size), SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Int64, Int64}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Int64, Int64}, Int64, Int64})
precompile(Tuple{typeof(Base.lastindex), SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64})
precompile(Tuple{typeof(Base.maybeview), SparseArrays.SparseMatrixCSC{Float64, Int64}, Base.UnitRange{Int64}, Function})
precompile(Tuple{typeof(Base.getindex), SparseArrays.SparseMatrixCSC{Float64, Int64}, Base.UnitRange{Int64}, Base.Colon})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{SparseArrays.HigherOrderFns.SparseMatStyle, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(*)), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64}})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Base.Broadcast.DefaultArrayStyle{2}, SparseArrays.HigherOrderFns.SparseMatStyle})
precompile(Tuple{typeof(Base.Broadcast.materialize!), Base.SubArray{Float64, 2, SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Base.UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{SparseArrays.HigherOrderFns.SparseMatStyle, Nothing, typeof(Base.:(*)), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64}}})
precompile(Tuple{typeof(Base.lastindex), Array{Float64, 1}, Int64})
precompile(Tuple{Type{Base.Slice{T} where T<:(Base.AbstractUnitRange{T} where T)}, Base.OneTo{Int64}})
precompile(Tuple{typeof(Base.ntuple), Base.Returns{Base.OneTo{Int64}}, Base.Val{2}})
precompile(Tuple{typeof(Base.tail), Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}})
precompile(Tuple{typeof(Base.rdims), Tuple{Base.OneTo{Int64}}, Tuple{}})
precompile(Tuple{typeof(Base.to_shape), Base.OneTo{Int64}})
precompile(Tuple{typeof(Base.ensure_indexable), Tuple{Base.Slice{Base.OneTo{Int64}}}})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 1}, Base.UnitRange{Int64}, Function})
precompile(Tuple{typeof(Base.getindex), Array{Float64, 1}, Base.UnitRange{Int64}, Function})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{Float64, 2}, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(*)), Tuple{Array{Float64, 2}, Int64}})
precompile(Tuple{typeof(Base.Broadcast.materialize!), Base.SubArray{Float64, 2, Array{Float64, 2}, Tuple{Base.UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2}, Nothing, typeof(Base.:(*)), Tuple{Array{Float64, 2}, Int64}}})
precompile(Tuple{typeof(Base.getproperty), SparseArrays.SparseMatrixCSC{Float64, Int64}, Symbol})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{Int64, 1}, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(-)), Tuple{Array{Int64, 1}, Int64}})
precompile(Tuple{typeof(Base.Broadcast.materialize), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(Base.:(-)), Tuple{Array{Int64, 1}, Int64}}})
precompile(Tuple{typeof(ECOS.ECOS_setup), Int64, Int64, Int64, Int64, Int64, Array{Int64, 1}, Int64, Array{Float64, 1}, Array{Int64, 1}, Array{Int64, 1}, Array{Float64, 1}, Array{Int64, 1}, Array{Int64, 1}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{Type{ECOS.settings}, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Int64, Int64, Int64, Float64, Float64})
precompile(Tuple{typeof(Base.getproperty), PMPC.ECOS_result, Symbol})
precompile(Tuple{typeof(Base.lastindex), Array{Float64, 1}})
precompile(Tuple{typeof(PMPC.split_lqp_vars), Array{PMPC.OCProb{Float64}, 1}, Int64, Array{Float64, 1}})
precompile(Tuple{Type{Pair{A, B} where B where A}, Symbol, Array{Float64, 1}})
precompile(Tuple{Type{Base.Dict{Symbol, Any}}, Pair{Symbol, Float64}, Vararg{Pair{A, B} where B where A}})
precompile(Tuple{typeof(PyCall.weakref_callback), Ptr{PyCall.PyObject_struct}, Ptr{PyCall.PyObject_struct}})
precompile(Tuple{typeof(PyCall.pyreturn), Tuple{Array{Float64, 3}, Array{Float64, 3}, Base.Dict{Symbol, Any}}})
precompile(Tuple{typeof(Base.similar), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(getfield), Tuple{Base.Broadcast.Extruded{Array{LinearAlgebra.BLAS.LBTLibraryInfo, 1}, Tuple{Bool}, Tuple{Int64}}, Base.RefValue{Symbol}}}, Type{String}})
precompile(Tuple{typeof(Base.Broadcast.copyto_nonleaf!), Array{String, 1}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(getfield), Tuple{Base.Broadcast.Extruded{Array{LinearAlgebra.BLAS.LBTLibraryInfo, 1}, Tuple{Bool}, Tuple{Int64}}, Base.RefValue{Symbol}}}, Base.OneTo{Int64}, Int64, Int64})
precompile(Tuple{typeof(Base.any), Function, Array{String, 1}})
precompile(Tuple{typeof(Base._any), Base.Fix2{typeof(Base.contains), String}, Array{String, 1}, Base.Colon})
precompile(Tuple{typeof(Base.cconvert), Type{Ptr{PyCall.PyObject_struct}}, PyCall.PyObject})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{PyCall.PyObject_struct}}, PyCall.PyObject})
precompile(Tuple{Type{PyCall.PyObject}, Float64})
precompile(Tuple{Type{PyCall.PyObject}, String})
precompile(Tuple{Type{PyCall.PyObject}, Array{Float64, 1}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), T} where T<:Tuple}, Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{Base.var"#invokelatest##kw", NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{Base.var"##invokelatest#2", Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{PMPC.var"#lcone_solve##kw", NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}, typeof(PMPC.lcone_solve), Array{Float64, 2}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}})
precompile(Tuple{Type{NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :slew_um1, :ux, :uu, :slew_reg), T} where T<:Tuple}, Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :slew_um1, :ux, :uu, :slew_reg), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :slew_um1, :ux, :uu, :slew_reg), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}}})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{PMPC.var"#make_prob##kw", NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :slew_um1, :ux, :uu, :slew_reg), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}}, typeof(PMPC.make_prob), Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}, PyCall.PyDict{Symbol, PyCall.PyObject, true}})
precompile(Tuple{typeof(Base.collect), Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}}})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Tuple{Symbol, Float64}, 1}, Tuple{Symbol, Float64}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}}, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.collect_to!), Array{Tuple{Symbol, Any}, 1}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}}, Int64, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:with_bridge_type,), Tuple{DataType}}, Symbol})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.Silent, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{MathOptInterface.Silent}}, MathOptInterface.Silent, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.Silent})
precompile(Tuple{Type{Base.Fix2{F, T} where T where F}, typeof(Base.isequal), Type})
precompile(Tuple{typeof(Base.isequal), Type})
precompile(Tuple{typeof(MutableArithmetics.mutability), Type, Function, Type, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_sum_mul), Type, Type})
precompile(Tuple{typeof(Base.argtail), Nothing})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_eltype), Type})
precompile(Tuple{typeof(MutableArithmetics._combine_styles), Type})
precompile(Tuple{typeof(MutableArithmetics._combine_styles), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_broadcast), typeof(MutableArithmetics.sub_mul), Type, Type})
precompile(Tuple{typeof(Base.Broadcast.combine_eltypes), Function, Tuple{DataType, DataType}})
precompile(Tuple{typeof(MutableArithmetics.broadcast_mutability), Type, Function, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(Base.:(*)), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(Base.:(+)), Type, Type})
precompile(Tuple{typeof(Base.promote_result), Type, Type, Type{Union{}}, Type{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}}})
precompile(Tuple{typeof(Base.promote_result), Type, Type, Type{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}}, Type{Union{}}})
precompile(Tuple{typeof(Base.promote_type), Type, Type, Type})
precompile(Tuple{typeof(Base.getindex), Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, Symbol})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(Base.:(*)), Type})
precompile(Tuple{typeof(MutableArithmetics._instantiate_zero), Type{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}}})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(Base.:(-)), Type{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}}, Type{Nothing}})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(Base.:(-)), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(MutableArithmetics.sub_mul), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(MutableArithmetics.sub_mul), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.mutability), Type, Function, Type, Type})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(MutableArithmetics.scaling_to_number), Tuple{Tuple{}}}}, Function, Tuple{Tuple{}}, Nothing})
precompile(Tuple{typeof(Base.axes), Tuple})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(typeof), Tuple{Tuple{MutableArithmetics.Zero, Nothing}}}}, Function, Tuple{Tuple{MutableArithmetics.Zero, Nothing}}, Nothing})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(JuMP.value), Nothing})
precompile(Tuple{typeof(Base.convert), Type{Ptr{OSQP.Workspace}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.promote_result), Type, Type, Type{Union{}}, Type{Union{Nothing, Float64}}})
precompile(Tuple{typeof(Base.getindex), Base.UnitRange{Int64}, Int64})
precompile(Tuple{typeof(Base.lastindex), Base.UnitRange{Int64}})
precompile(Tuple{typeof(Base.promote_result), Type, Type, Type{Union{Nothing, Float64}}, Type{Union{Nothing, Float64}}})
precompile(Tuple{typeof(Base._after_colon), Base.Colon})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{5}})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{7}})
precompile(Tuple{Type{Random.Sampler{E} where E}, Random.TaskLocalRNG, Base.UnitRange{Int64}, Base.Val{1}})
precompile(Tuple{typeof(Base.:(-)), UInt64})
precompile(Tuple{typeof(Base.mod), UInt64, UInt64})
precompile(Tuple{PMPC.var"#lqp_solve##kw", NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}, typeof(PMPC.lqp_solve), Array{Float64, 2}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}})
precompile(Tuple{typeof(Base.empty), Base.Dict{Any, Any}, Type{Symbol}, Type{Float64}})
precompile(Tuple{typeof(Base.setindex!), Base.Dict{Symbol, Float64}, Float64, Symbol})
precompile(Tuple{typeof(Base.grow_to!), Base.Dict{Symbol, Float64}, Base.Generator{Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}}, PMPC.var"#101#102"}, Int64})
precompile(Tuple{typeof(Base.empty), Base.Dict{Symbol, Float64}, Type{Symbol}, Type{Any}})
precompile(Tuple{typeof(Base.merge!), Base.Dict{Symbol, Any}, Base.Dict{Symbol, Float64}})
precompile(Tuple{typeof(Base.grow_to!), Base.Dict{Symbol, Any}, Base.Generator{Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}}, PMPC.var"#101#102"}, Int64})
precompile(Tuple{typeof(Base.get), Base.Dict{Symbol, Any}, Symbol, Bool})
precompile(Tuple{typeof(Base.get), Base.Dict{Symbol, Any}, Symbol, Int64})
precompile(Tuple{typeof(Base.get), Base.Dict{Symbol, Any}, Symbol, Nothing})
precompile(Tuple{typeof(PMPC.lqp_repr_Pq), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{typeof(Base.mapreduce_first), PMPC.var"#46#48"{Array{PMPC.OCProb{Float64}, 1}}, Function, Int64})
precompile(Tuple{typeof(Base.reduce_first), Function, Array{Float64, 1}})
precompile(Tuple{typeof(Base.haskey), Base.Dict{Symbol, Any}, Symbol})
precompile(Tuple{Type{PMPC.OSQPSolver{Float64}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing})
precompile(Tuple{typeof(Base.setproperty!), PMPC.OSQPSolver{Float64}, Symbol, Array{Float64, 1}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :lu, :uu, :reg_u, :solver, :solver_state, :lx, :ux), T} where T<:Tuple}, Tuple{Float64, Array{Float64, 3}, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, NamedTuple{(:reg_x, :lu, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:reg_x, :lu, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}})
precompile(Tuple{PMPC.var"#solve_qp!##kw", NamedTuple{(:reg_x, :lu, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}, typeof(PMPC.solve_qp!), PMPC.OSQPSolver{Float64}})
precompile(Tuple{Type{NamedTuple{(:P, :q, :A, :l, :u), T} where T<:Tuple}, Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(:P, :q, :A, :l, :u), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}}}, Base.Dict{Symbol, Any}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), T} where T<:Tuple}, Tuple{Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}})
precompile(Tuple{Base.var"##s83#216", Any, Any, Any, Any, Any})
precompile(Tuple{typeof(Base._nt_names), Type{NamedTuple{(:reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(:P, :q, :A, :l, :u), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}}}, NamedTuple{(:reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}}, Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}})
precompile(Tuple{typeof(Base.Broadcast._getindex), Tuple{Float64}, Int64})
precompile(Tuple{OSQP.var"#setup!##kw", NamedTuple{(:P, :q, :A, :l, :u, :reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}, typeof(OSQP.setup!), OSQP.Model})
precompile(Tuple{typeof(Base._array_for), Type{Float64}, Base.HasLength, Int64})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Float64, 1}, Float64, Base.Generator{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}, OSQP.var"#7#8"{Base.Dict{Symbol, Any}, OSQP.Settings}}, Int64})
precompile(Tuple{typeof(Base.setindex_widen_up_to), Array{Float64, 1}, Int64, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Real, 1}, Base.Generator{Tuple{Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol, Symbol}, OSQP.var"#7#8"{Base.Dict{Symbol, Any}, OSQP.Settings}}, Int64, Int64})
precompile(Tuple{Type{OSQP.Settings}, Float64, Float64, Int64, Int64, Int64, Float64, Float64, Int64, Float64, Float64, Float64, Float64, Float64, Int32, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Float64})
precompile(Tuple{Type{Ref{T} where T}, OSQP.Settings})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{OSQP.Settings}}, Base.RefValue{OSQP.Settings}})
precompile(Tuple{PMPC.var"#JuMP_solve##kw", NamedTuple{(:verbose,), Tuple{Bool}}, typeof(PMPC.JuMP_solve), PMPC.ConeProblem})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Int64, 1}, Int64, Base.Generator{Array{Symbol, 1}, PMPC.var"#61#65"{PMPC.ConeProblem}}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Any, 1}, Base.Generator{Array{Symbol, 1}, PMPC.var"#61#65"{PMPC.ConeProblem}}, Int64, Int64})
precompile(Tuple{typeof(JuMP._moi_mode), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}})
precompile(Tuple{MathOptInterface.var"##instantiate#25", Type{Float64}, Nothing, typeof(MathOptInterface.instantiate), Any})
precompile(Tuple{typeof(MathOptInterface._instantiate_and_check), Any})
precompile(Tuple{typeof(Mosek.msk_stream_callback_wrapper), Ptr{Nothing}, Ptr{UInt8}})
precompile(Tuple{typeof(Mosek.msk_info_callback_wrapper), Ptr{Nothing}, Ptr{Nothing}, Int32, Ptr{Float64}, Ptr{Int32}, Ptr{Int64}})
precompile(Tuple{typeof(Mosek.Optimizer)})
precompile(Tuple{typeof(MathOptInterface.is_empty), MosekTools.Optimizer})
precompile(Tuple{typeof(MathOptInterface.set), MosekTools.Optimizer, MathOptInterface.RawOptimizerAttribute, Bool})
precompile(Tuple{typeof(MathOptInterface.supports_incremental_interface), MosekTools.Optimizer})
precompile(Tuple{typeof(MathOptInterface.Bridges.full_bridge_optimizer), MosekTools.Optimizer, Type{Float64}})
precompile(Tuple{typeof(MathOptInterface.Bridges.add_bridge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.FreeBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.VectorizeBridge{Float64, S} where S}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.SOCtoRSOCBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.RSOCtoSOCBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.RSOCtoPSDBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Variable.ParameterToEqualToBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Objective.QuadratizeBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Objective.SlackBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Objective.VectorFunctionizeBridge{Float64}}}, Type})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Objective.VectorSlackBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}}, Type})
precompile(Tuple{Type{MathOptInterface.RawOptimizerAttribute}, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.TimeLimitSec, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{MathOptInterface.TimeLimitSec}}, MathOptInterface.TimeLimitSec, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.TimeLimitSec})
precompile(Tuple{typeof(OSQP.clean!), OSQP.Model})
precompile(Tuple{Type{MathOptInterface.Utilities.CachingOptimizer{O, M} where M<:MathOptInterface.ModelLike where O}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}})
precompile(Tuple{Type{Base.OneTo{T} where T<:Integer}, Base.UnitRange{Int64}})
precompile(Tuple{typeof(JuMP.Containers.vectorized_product), Base.OneTo{Int64}})
precompile(Tuple{typeof(JuMP.Containers.container), Function, JuMP.Containers.VectorizedProductIterator{Tuple{Base.OneTo{Int64}}}, Type{JuMP.Containers.AutoContainerType}, Array{Any, 1}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, JuMP.Containers.var"#80#81"{PMPC.var"#64#68"}, JuMP.Containers.VectorizedProductIterator{Tuple{Base.OneTo{Int64}}}})
precompile(Tuple{typeof(Base.collect), Base.Generator{JuMP.Containers.VectorizedProductIterator{Tuple{Base.OneTo{Int64}}}, JuMP.Containers.var"#80#81"{PMPC.var"#64#68"}}})
precompile(Tuple{Type{MosekTools.MatrixIndex}, Int64, Int64, Int64})
precompile(Tuple{typeof(Base.convert), Type{Mosek.Boundkey}, Mosek.Boundkey})
precompile(Tuple{typeof(Base.Broadcast.broadcastable), Int32})
precompile(Tuple{typeof(Base.Broadcast.extrude), Int32})
precompile(Tuple{typeof(Base.Broadcast._getindex), Tuple{Int32}, Int64})
precompile(Tuple{typeof(Base.getindex), Int32})
precompile(Tuple{typeof(Base.:(==)), Nothing, Type})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Type, Type}}, Tuple{DataType, DataType}})
precompile(Tuple{Type{MathOptInterface.Bridges.ObjectiveNode}, Int64})
precompile(Tuple{Type{MathOptInterface.Bridges.VariableNode}, Int64})
precompile(Tuple{Type{MathOptInterface.Bridges.ConstraintNode}, Int64})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.VariablePrimalStart})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.VariablePrimalStart, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{MathOptInterface.VariablePrimalStart}}, MathOptInterface.VariablePrimalStart, String})
precompile(Tuple{typeof(JuMP._moi_add_variable), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, JuMP.Model, JuMP.ScalarVariable{Float64, Float64, Float64, Float64}, String})
precompile(Tuple{typeof(MathOptInterface.set), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VariableName, MathOptInterface.VariableIndex, String})
precompile(Tuple{typeof(Base.setindex!), JuMP.Model, Array{JuMP.VariableRef, 1}, Symbol})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(MutableArithmetics.add_mul), Type, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.add_mul), MutableArithmetics.Zero, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{JuMP.VariableRef, 1}})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.sub_mul), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.copyto!), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}}, MutableArithmetics.var"#f#1"{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(MutableArithmetics.sub_mul), Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}}, Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), MutableArithmetics.var"#f#1"{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(MutableArithmetics.sub_mul), Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}}, JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, Float64})
precompile(Tuple{MutableArithmetics.var"#f#1"{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(MutableArithmetics.sub_mul), Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}}, JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, Float64})
precompile(Tuple{typeof(Base.Broadcast.broadcastable), Tuple{DataType, DataType}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(MutableArithmetics._shape), Tuple{Tuple{DataType, DataType}}}}, Function, Tuple{Tuple{DataType, DataType}}, Nothing})
precompile(Tuple{typeof(Base.Broadcast.instantiate), Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(MutableArithmetics._shape), Tuple{Tuple{DataType, DataType}}}})
precompile(Tuple{typeof(MutableArithmetics._shape), Type})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(MutableArithmetics._shape), Type})
precompile(Tuple{typeof(MutableArithmetics.broadcast!!), typeof(MutableArithmetics.sub_mul), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Int64})
precompile(Tuple{typeof(JuMP._functionize), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}})
precompile(Tuple{typeof(JuMP._desparsify), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}})
precompile(Tuple{Type{Base.RefValue{T} where T}, JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, JuMP.Model, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}}, String})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(JuMP.add_constraint), Tuple{Base.RefValue{JuMP.Model}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}}, Base.RefValue{String}}})
precompile(Tuple{Type{MathOptInterface.EqualTo{T} where T<:Number}, Float64})
precompile(Tuple{typeof(MathOptInterface.constant), MathOptInterface.EqualTo{Float64}})
precompile(Tuple{typeof(Base.Broadcast.materialize), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.add_constraint), Tuple{Base.RefValue{JuMP.Model}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}}, Base.RefValue{String}}}})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.sub_mul), MutableArithmetics.Zero, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{JuMP.VariableRef, 1}})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(MutableArithmetics.add_mul), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(MutableArithmetics.add_mul), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.add_mul), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}})
precompile(Tuple{Type{MathOptInterface.Nonnegatives}, Int64})
precompile(Tuple{typeof(JuMP.build_constraint), Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(JuMP.add_constraint), JuMP.Model, JuMP.VectorConstraint{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, MathOptInterface.Nonnegatives, JuMP.VectorShape}, String})
precompile(Tuple{typeof(Base.convert), Type{Type{MathOptInterface.VectorAffineTerm{T} where T}}, Type{MathOptInterface.VectorAffineTerm{T} where T}})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(OrderedCollections.hashindex), Tuple{DataType, DataType}, Int64})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Utilities.scalar_set_type), Type{MathOptInterface.Nonpositives}, Type})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.ScalarAffineFunction{Float64}}, Type{MathOptInterface.LessThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonpositives}}})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Type}}, Tuple{DataType}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}})
precompile(Tuple{typeof(MathOptInterface.Utilities.is_coefficient_type), Type{MathOptInterface.VectorOfVariables}, Type})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VariableIndex}, Type{MathOptInterface.LessThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, MathOptInterface.Nonpositives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ZerosBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.FreeBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.concrete_bridge_type), Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Utilities.scalar_set_type), Type{MathOptInterface.Nonnegatives}, Type})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VariableIndex}, Type{MathOptInterface.GreaterThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, MathOptInterface.Nonnegatives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ZerosBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.FreeBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.VectorizeBridge{Float64, S} where S}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.SOCtoRSOCBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoSOCBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoPSDBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ParameterToEqualToBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.VectorizeBridge{Float64, S} where S}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.SOCtoRSOCBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoSOCBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoPSDBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ParameterToEqualToBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Utilities.scalar_set_type), Type{MathOptInterface.Zeros}, Type})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.ScalarAffineFunction{Float64}}, Type{MathOptInterface.EqualTo{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Zeros, MathOptInterface.Nonnegatives, MathOptInterface.Nonpositives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.ScalarAffineFunction{Float64}}, Type{MathOptInterface.GreaterThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{Type{MathOptInterface.SecondOrderCone}, Int64})
precompile(Tuple{typeof(JuMP.build_constraint), Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, MathOptInterface.SecondOrderCone})
precompile(Tuple{typeof(JuMP.add_constraint), JuMP.Model, JuMP.VectorConstraint{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, MathOptInterface.SecondOrderCone, JuMP.VectorShape}, String})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone})
precompile(Tuple{typeof(JuMP.build_constraint), Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, MathOptInterface.ExponentialCone})
precompile(Tuple{typeof(JuMP.add_constraint), JuMP.Model, JuMP.VectorConstraint{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, MathOptInterface.ExponentialCone, JuMP.VectorShape}, String})
precompile(Tuple{typeof(Base.first), Base.StepRange{Int64, Int64}})
precompile(Tuple{typeof(Base.step_hp), Base.StepRange{Int64, Int64}})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone})
precompile(Tuple{typeof(Base.adjoint), Array{Float64, 1}})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(Base.adjoint), Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(Base.adjoint), Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(LinearAlgebra.dot), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(MutableArithmetics.add_dot), Type, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(MutableArithmetics.add_dot), Type, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_map_reduce), Function, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.buffer_for), typeof(MutableArithmetics.add_mul), Type, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.buffer_for), typeof(MutableArithmetics.add_dot), Type, Type, Type})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.add_mul), MutableArithmetics.Zero, LinearAlgebra.Adjoint{Float64, Array{Float64, 1}}, Array{JuMP.VariableRef, 1}})
precompile(Tuple{typeof(JuMP._replace_zero), JuMP.GenericAffExpr{Float64, JuMP.VariableRef}})
precompile(Tuple{typeof(JuMP.set_objective), JuMP.Model, MathOptInterface.OptimizationSense, JuMP.GenericAffExpr{Float64, JuMP.VariableRef}})
precompile(Tuple{typeof(MathOptInterface.set), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ObjectiveSense, MathOptInterface.OptimizationSense})
precompile(Tuple{typeof(MathOptInterface.supports), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ObjectiveFunction{MathOptInterface.ScalarAffineFunction{Float64}}})
precompile(Tuple{typeof(MathOptInterface.set), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ObjectiveFunction{MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.ScalarAffineFunction{Float64}})
precompile(Tuple{typeof(JuMP._moi_mode), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}})
precompile(Tuple{typeof(Base.Iterators._flatten_iteratorsize), Base.HasShape{1}, Base.EltypeUnknown, Type})
precompile(Tuple{Type{MathOptInterface.UnsupportedAttribute{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.VariableName, String})
precompile(Tuple{Type{MathOptInterface.UnsupportedAttribute{MathOptInterface.VariableName}}, MathOptInterface.VariableName, String})
precompile(Tuple{typeof(MathOptInterface.VariableIndexConstraintNameError)})
precompile(Tuple{Type{NamedTuple{(:by, :rev), T} where T<:Tuple}, Tuple{MosekTools.var"#16#17", Bool}})
precompile(Tuple{Type{Base.Order.By{MosekTools.var"#16#17", Base.Order.ForwardOrdering}}, Function, Base.Order.ForwardOrdering})
precompile(Tuple{Type{Base.Order.By{MosekTools.var"#16#17", Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}}}, Function, Base.Order.ReverseOrdering{Base.Order.ForwardOrdering}})
precompile(Tuple{typeof(Base.haskey), NamedTuple{(:by, :rev), Tuple{MosekTools.var"#16#17", Bool}}, Symbol})
precompile(Tuple{typeof(MathOptInterface.optimize!), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}})
precompile(Tuple{MathOptInterface.Utilities.var"#121#124", Tuple{DataType, DataType}})
precompile(Tuple{typeof(MathOptInterface.supports), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.VariableName, Type{MathOptInterface.VariableIndex}})
precompile(Tuple{typeof(MathOptInterface.supports), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.ObjectiveSense})
precompile(Tuple{typeof(MathOptInterface.Utilities._pass_attribute), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, MathOptInterface.ObjectiveSense})
precompile(Tuple{typeof(MathOptInterface.Utilities._pass_attribute), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, MathOptInterface.ObjectiveFunction{MathOptInterface.ScalarAffineFunction{Float64}}})
precompile(Tuple{MathOptInterface.Utilities.var"#117#119", Tuple{DataType, DataType}})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{DataType, DataType}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{DataType, DataType}, Int64, Int64})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.ListOfConstraintIndices{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MosekTools.Optimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, 1}})
precompile(Tuple{Type{MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MosekTools.Optimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}, 1}})
precompile(Tuple{Type{MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MosekTools.Optimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}, 1}})
precompile(Tuple{Type{MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}, 1}})
precompile(Tuple{typeof(Base.setindex!), Base.Dict{Any, Type}, Type, Tuple{DataType, DataType}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.add_bridged_constraint), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.bridge_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}, MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.add_key_for_bridge), MathOptInterface.Bridges.Constraint.Map, MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, 1}})
precompile(Tuple{typeof(Base.tail), Tuple{DataType, DataType}})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}, 1}})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.ConstraintFunction})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.ConstraintFunction, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{MathOptInterface.ConstraintFunction}}, MathOptInterface.ConstraintFunction, String})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}, 1}})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}, 1}})
precompile(Tuple{typeof(Base.cconvert), Type, Base.RefValue{Int32}})
precompile(Tuple{typeof(Base.convert), Type{Ref{Int32}}, Base.RefValue{Int32}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ref{Int32}}, Base.RefValue{Int32}})
precompile(Tuple{typeof(Base.getindex), Base.RefValue{Int32}})
precompile(Tuple{Type{Array{Int32, 1}}, UndefInitializer, Int32})
precompile(Tuple{typeof(Base.disable_sigint), Mosek.var"#376#379"{Mosek.Task, Mosek.Soltype, Array{Int32, 1}}})
precompile(Tuple{typeof(Base._array_for), Type{Mosek.Stakey}, Array{Int32, 1}, Base.HasShape{1}})
precompile(Tuple{Type{Base.LinearIndices{N, R} where R<:Tuple{Vararg{Base.AbstractUnitRange{Int64}, N}} where N}, Array{Mosek.Stakey, 1}})
precompile(Tuple{Type{Mosek.Stakey}, Int32})
precompile(Tuple{typeof(Base.setindex!), Array{Mosek.Stakey, 1}, Mosek.Stakey, Int64})
precompile(Tuple{typeof(Base.disable_sigint), Mosek.var"#370#373"{Mosek.Task, Mosek.Soltype, Array{Int32, 1}}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{JuMP.VariableRef, 1}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(JuMP.value), Tuple{Array{JuMP.VariableRef, 1}}})
precompile(Tuple{typeof(Base.Broadcast.materialize), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.value), Tuple{Array{JuMP.VariableRef, 1}}}})
precompile(Tuple{typeof(Base.convert), Type{MathOptInterface.TerminationStatusCode}, MathOptInterface.TerminationStatusCode})
precompile(Tuple{typeof(JuMP._moi_get_result), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VariablePrimal, Vararg{Any}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VariablePrimal, MathOptInterface.VariableIndex})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.VariablePrimal, MathOptInterface.VariableIndex})
precompile(Tuple{typeof(MathOptInterface.Bridges.unbridged_function), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Float64})
precompile(Tuple{typeof(MathOptInterface.Utilities.map_indices), MathOptInterface.Utilities.IndexMap, MathOptInterface.VariablePrimal, Float64})
precompile(Tuple{Type{NamedTuple{(:x,), T} where T<:Tuple}, Tuple{Array{Float64, 1}}})
precompile(Tuple{typeof(Base.getproperty), NamedTuple{(:x,), Tuple{Array{Float64, 1}}}, Symbol})
precompile(Tuple{typeof(Base._atexit)})
precompile(Tuple{Base.var"#886#887"})
precompile(Tuple{typeof(Mosek.deletetask), Mosek.Task})
precompile(Tuple{typeof(Base.uvfinalize), Base.AsyncCondition})
precompile(Tuple{Type{NamedTuple{(:exception,), T} where T<:Tuple}, Tuple{Tuple{Base.EOFError, Array{Union{Ptr{Nothing}, Base.InterpreterIP}, 1}}}})





