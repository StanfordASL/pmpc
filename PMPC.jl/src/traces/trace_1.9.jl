using Core
using Random
using PMPC
using OpenSpecFun_jll
using JuMP
using MosekTools
using IterTools
using OrderedCollections
using LinearAlgebra
using OSQP
using OSQP_jll
using COSMO
using PyCall
using JLLWrappers
using SparseArrays
using ECOS_jll
using Artifacts
using ECOS
using Mosek
#using _jll
#using _PyJuliaHelper
using Requires
using MutableArithmetics
using MathOptInterface
precompile(Tuple{typeof(Base.getindex), Base.RefValue{Bool}})
precompile(Tuple{typeof(Base.escape_string), String})
precompile(Tuple{Type{PyCall.PyError}, String, PyCall.PyError})
precompile(Tuple{typeof(Base.isimmutable), Any})
precompile(Tuple{typeof(PyCall.typetuple), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#36#37"{PyCall.PyObject}}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#36#37"{PyCall.PyObject}}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#36#37"{PyCall.PyObject}}, Int64})
precompile(Tuple{typeof(Base.MainInclude.include), String})
precompile(Tuple{typeof(Base.require), Base.PkgId})
precompile(Tuple{Type{Ref{IO}}})
precompile(Tuple{Type{Ref{Base.PipeEndpoint}}})
#precompile(Tuple{typeof(_PyJuliaHelper.IOPiper.__init__)})
precompile(Tuple{typeof(Base.require), Module, Symbol})
precompile(Tuple{typeof(Base._require_prelocked), Base.PkgId, String})
precompile(Tuple{typeof(Base.hashindex), Tuple{Base.PkgId, Nothing}, Int64})
precompile(Tuple{typeof(Base.hashindex), Tuple{Base.PkgId, String}, Int64})
precompile(Tuple{typeof(OSQP_jll.find_artifact_dir)})
precompile(Tuple{typeof(Base._tuple_unique_fieldtypes), Any})
precompile(Tuple{typeof(Artifacts._artifact_str), Module, String, Base.SubString{String}, String, Base.Dict{String, Any}, Base.SHA1, Base.BinaryPlatforms.Platform, Any})
precompile(Tuple{typeof(Base.invokelatest), Any})
precompile(Tuple{typeof(JLLWrappers.get_julia_libpaths)})
precompile(Tuple{typeof(OpenSpecFun_jll.find_artifact_dir)})
precompile(Tuple{typeof(Base.first), Array{Any, 1}})
#precompile(Tuple{typeof(Bzip2_jll.find_artifact_dir)})
precompile(Tuple{typeof(ECOS_jll.find_artifact_dir)})
precompile(Tuple{typeof(Base.Libc.Libdl.dlsym), Ptr{Nothing}, String})
precompile(Tuple{typeof(Requires.loadpkg), Base.PkgId})
precompile(Tuple{typeof(Requires.listenpkg), Any, Base.PkgId})
precompile(Tuple{typeof(Requires.loaded), Base.PkgId})
precompile(Tuple{typeof(Requires.callbacks), Base.PkgId})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N}}, PyCall.PyObject})
precompile(Tuple{typeof(Base.length), Core.SimpleVector})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#9#10"{PyCall.PyBuffer}}})
precompile(Tuple{typeof(Base.iterate), Base.Generator{Base.UnitRange{Int64}, PyCall.var"#9#10"{PyCall.PyBuffer}}, Int64})
precompile(Tuple{Type{PyCall.PyArray_Info{Float64, 2}}, Bool, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Ptr{Nothing}, Bool, PyCall.PyBuffer})
precompile(Tuple{typeof(PyCall.pyocopy), PyCall.PyArray{Float64, 2}})
precompile(Tuple{Type{PyCall.PyArray_Info{Float64, 3}}, Bool, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Ptr{Nothing}, Bool, PyCall.PyBuffer})
precompile(Tuple{typeof(PyCall.pyocopy), PyCall.PyArray{Float64, 3}})
precompile(Tuple{Type{PyCall.PyArray_Info{Float64, 4}}, Bool, NTuple{4, Int64}, NTuple{4, Int64}, Ptr{Nothing}, Bool, PyCall.PyBuffer})
precompile(Tuple{Type{PyCall.PyArray{Float64, 4}}, PyCall.PyObject, PyCall.PyArray_Info{Float64, 4}})
precompile(Tuple{Type{Base.IteratorsMD.CartesianIndex{N} where N}, NTuple{4, Int64}})
precompile(Tuple{typeof(PyCall.pyocopy), PyCall.PyArray{Float64, 4}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}, PyCall.PyDict{Symbol, PyCall.PyObject, true}})
precompile(Tuple{typeof(Base.collect), Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ref{Int64}}, Base.RefValue{Int64}})
precompile(Tuple{typeof(Base._array_for), Type{Tuple{Symbol, Float64}}, Base.HasLength, Int64})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Tuple{Symbol, Float64}, 1}, Tuple{Symbol, Float64}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}}, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.setindex_widen_up_to), Array{Tuple{Symbol, Float64}, 1}, Tuple{Symbol, Array{Float64, 3}}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Tuple{Symbol, Any}, 1}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lcone_solve)}}, Int64, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, Array{Tuple{Symbol, Any}, 1}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), T} where T<:Tuple}, Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{Base.var"##invokelatest#2", Base.Pairs{Symbol, Any, NTuple{10, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{typeof(Base.tail), NTuple{4, Symbol}})
precompile(Tuple{typeof(Base.:(<)), Int64})
precompile(Tuple{Type{Base.Slice{T} where T<:(Base.AbstractUnitRange{T} where T)}, Base.OneTo{Int64}})
precompile(Tuple{typeof(Base.:(&)), Bool, Base.Missing})
precompile(Tuple{typeof(Base.ntuple), Base.Returns{Base.OneTo{Int64}}, Base.Val{3}})
precompile(Tuple{typeof(Base.ntuple), Base.Returns{Base.OneTo{Int64}}, Base.Val{2}})
precompile(Tuple{Type{NamedTuple{(:outer,), T} where T<:Tuple}, Tuple{Tuple{Int64}}})
precompile(Tuple{typeof(Base.any), Function, Tuple{Int64}})
precompile(Tuple{typeof(Base._any), Base.Fix2{typeof(Base.:(<)), Int64}, Tuple{Int64}, Base.Colon})
precompile(Tuple{typeof(Base._RepeatInnerOuter.to_tuple), Tuple{Int64}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Nothing, 1}}})
precompile(Tuple{Type{Base.Broadcast.BroadcastStyle}, Type{Nothing}})
precompile(Tuple{typeof(Base.Broadcast.combine_styles), Nothing})
precompile(Tuple{typeof(Base.axes), Nothing})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(Base.eltype), typeof(Base.promote_type)}, Type{Array{Float64, 1}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(Base.eltype), typeof(Base.promote_type)}, Type{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{Base.var"#144#146", typeof(Base.add_sum)}, Type{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{Type{Signed}, UInt64})
precompile(Tuple{typeof(Base.:(+)), Int64, Float64})
precompile(Tuple{typeof(Base.:(-)), Int64, Float64})
precompile(Tuple{typeof(Base.:(-)), LinearAlgebra.UniformScaling{Bool}})
precompile(Tuple{typeof(Base.tail), Tuple{Bool, Bool}})
precompile(Tuple{Base.ComposedFunction{typeof(Base.:(!)), typeof(Base.iszero)}, Bool})
precompile(Tuple{SparseArrays.HigherOrderFns.var"#21#24", Float64})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(Base.adjoint), Float64})
precompile(Tuple{typeof(Base.iterate), Int64})
precompile(Tuple{typeof(Base.Iterators.zip), Int64, Int64})
precompile(Tuple{typeof(Base.iterate), Base.Iterators.Zip{Tuple{Int64, Int64}}})
precompile(Tuple{Type{Pair{Symbol, Any}}, Any, Any})
precompile(Tuple{typeof(Base._cshp), Int64, Tuple{Bool, Bool}, Tuple{}, Tuple{Int64}})
precompile(Tuple{typeof(Base.iszero), Nothing})
precompile(Tuple{typeof(SparseArrays._isnotzero), Nothing})
precompile(Tuple{typeof(Base.Broadcast.broadcastable), Int64})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Float64, 1}}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Real, 1}}})
precompile(Tuple{Type{Ptr{ECOS.pwork}}, Int64})
precompile(Tuple{Type{COSMO.ZeroSet{Float64}}, Int64})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{COSMO.var"#18#20", typeof(Base.add_sum)}, Type{COSMO.ZeroSet{Float64}}})
precompile(Tuple{Type{NamedTuple{(:mem,), T} where T<:Tuple}, Tuple{Int64}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:mem,), Tuple{Int64}}, typeof(COSMO.with_options), Type})
precompile(Tuple{typeof(COSMO.with_options), Type})
precompile(Tuple{Type{NamedTuple{(:logical,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{Base.var"##s92#239", Vararg{Any, 5}})
precompile(Tuple{typeof(Base.reduce_empty), Base.BottomRF{typeof(Base.min)}, Type{Int64}})
precompile(Tuple{Type{NamedTuple{(:by, :rev), T} where T<:Tuple}, Tuple{COSMO.var"#86#88", Bool}})
precompile(Tuple{typeof(IterTools.pop), Tuple{Int64, Int64}})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Tuple{Int64}, Int64}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Tuple{Int64}, Int64}, Int64, Int64})
precompile(Tuple{Type{DomainError}, Any})
precompile(Tuple{Type{NamedTuple{(:alg, :rev), T} where T<:Tuple}, Tuple{Base.Sort.QuickSortAlg, Bool}})
precompile(Tuple{Type{NamedTuple{(:step,), T} where T<:Tuple}, Tuple{Int64}})
precompile(Tuple{Type{NamedTuple{(:allow_legacy_dispatch,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base._nt_names), Type{NamedTuple{(:allow_legacy_dispatch,), Tuple{Bool}}}})
precompile(Tuple{typeof(SparseArrays._iszero), Int64})
precompile(Tuple{Type{NamedTuple{(:unsafe,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base.:(<=)), UInt8, UInt64})
precompile(Tuple{typeof(Base.rem), UInt8, Type{UInt64}})
precompile(Tuple{typeof(Base._nt_names), Type{NamedTuple{(:scratch,), Tuple{Array{Tuple{Int64, Int64, Int64}, 1}}}}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{COSMO.var"#18#20", typeof(Base.add_sum)}, Type{COSMO.AbstractConvexSet{Float64}}})
precompile(Tuple{Type{BoundsError}, Any})
precompile(Tuple{typeof(Base.:(*)), Float64, LinearAlgebra.UniformScaling{Bool}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Float64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.identity), Tuple{Float64}})
precompile(Tuple{typeof(Base.getindex), Float64})
precompile(Tuple{Type{NamedTuple{(:reset,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(LinearAlgebra.norm), Float64})
precompile(Tuple{typeof(Base.float), Float64})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(LinearAlgebra.norm), typeof(Base.max)}, Type{Float64}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{Base.ComposedFunction{typeof(Base.float), typeof(LinearAlgebra.norm)}, typeof(Base.:(+))}, Type{Float64}})
precompile(Tuple{typeof(Base.reduce_empty), Base.MappingRF{typeof(LinearAlgebra.norm), typeof(Base.min)}, Type{Float64}})
precompile(Tuple{typeof(Base.:(==)), Float64, Int64})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex), Float64, Int64})
precompile(Tuple{typeof(Base.iszero), Bool})
precompile(Tuple{Base.ComposedFunction{typeof(Base.:(!)), typeof(Base.iszero)}, Float64})
precompile(Tuple{Type{Base.Pairs{Symbol, V, I, A} where A where I where V}, NamedTuple{(:by,), Tuple{COSMO.var"#137#138"}}, Tuple{Symbol}})
precompile(Tuple{typeof(Base._nt_names), Type{NamedTuple{(:scratch,), Tuple{Array{COSMO.AbstractConvexSet{T} where T, 1}}}}})
precompile(Tuple{typeof(Base.indexed_iterate), Pair{String, String}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Pair{String, String}, Int64, Int64})
precompile(Tuple{Type{NamedTuple{(:tab,), T} where T<:Tuple}, Tuple{Int64}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Type, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Axes, F, Args} where Args<:Tuple where F where Axes}, Type{Float64}, Tuple{Int64}})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0}, Nothing, Type{Float64}, Tuple{Int64}}, Int64})
precompile(Tuple{typeof(Base.promote), Bool, Bool, Float64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Float64, Float64, Float64}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Float64, Float64, Float64}, Int64, Int64})
precompile(Tuple{typeof(LinearAlgebra.BLAS.chkuplo), Char})
precompile(Tuple{typeof(Base.:(!=)), Char, Char})
precompile(Tuple{Type{Float32}, Float32})
precompile(Tuple{typeof(Base.:(/)), Float64, Int64})
precompile(Tuple{typeof(Base.:(*)), Float64, Float64})
precompile(Tuple{Base.var"#53#54", Tuple{}})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(Base.:(-)), Float64})
precompile(Tuple{typeof(LinearAlgebra.dot), Float64, Float64})
precompile(Tuple{typeof(LinearAlgebra.throw_uplo)})
precompile(Tuple{typeof(LinearAlgebra.char_uplo), Symbol})
precompile(Tuple{Type{NamedTuple{(:check,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base.sqrt), Int64})
precompile(Tuple{Base.Iterators.var"#7#8"{Tuple{Array{Base.SubArray{Float64, 1, Array{Float64, 1}, Tuple{Base.UnitRange{Int64}}, true}, 1}, Array{COSMO.AbstractConvexSet{T} where T, 1}}}, Int64})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Base.HasEltype, 1}}})
precompile(Tuple{typeof(Base.isvarargtype), Any})
precompile(Tuple{typeof(Base.fieldtypes), Type})
precompile(Tuple{typeof(Base.Iterators.map), Function, Tuple{DataType, DataType}})
precompile(Tuple{typeof(Base.add_sum), Float64, Float64})
precompile(Tuple{Type{NamedTuple{(:modifier,), T} where T<:Tuple}, Tuple{String}})
precompile(Tuple{typeof(Core.toUInt16), Int64})
precompile(Tuple{typeof(COSMO.free_memory!), Nothing})
precompile(Tuple{typeof(Base.get), Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, Symbol, Bool})
precompile(Tuple{Type{Pair{A, B} where B where A}, String, Bool})
precompile(Tuple{Core.Compiler.var"#360#361", Any})
precompile(Tuple{typeof(MathOptInterface._to_param), Pair{String, Bool}})
precompile(Tuple{Type{NamedTuple{(:with_bridge_type,), T} where T<:Tuple}, Tuple{DataType}})
precompile(Tuple{Type{NamedTuple{(:add_bridges,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base.tail), Tuple{Base.Colon, Base.Colon, Int64}})
precompile(Tuple{typeof(Base.tail), Tuple{Base.Colon, Int64}})
precompile(Tuple{typeof(Base.maybeview), Nothing, Function, Int64})
precompile(Tuple{typeof(Base.maybeview), Nothing, Function, Function, Vararg{Any}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :smooth_cstr, :smooth_alpha, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, String, Float64, Nothing}}, typeof(PMPC.lcone_solve), Array{Float64, 2}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}})
precompile(Tuple{Type{Pair{A, B} where B where A}, Symbol, Float64})
precompile(Tuple{Type{Pair{A, B} where B where A}, Symbol, Array{Float64, 3}})
precompile(Tuple{PMPC.var"#84#89", Array{Float64, 3}})
precompile(Tuple{typeof(Base.map), PMPC.var"#84#89", Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}})
precompile(Tuple{typeof(Base.size), Float64})
precompile(Tuple{typeof(Base.repeat), Array{Float64, 1}, Int64})
precompile(Tuple{typeof(Base.:(!=)), Array{Float64, 3}, Nothing})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 3}, Function, Function, Vararg{Any}})
precompile(Tuple{typeof(Base.view), Array{Float64, 3}, Function, Function, Int64})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 1}, Int64})
precompile(Tuple{typeof(Base.:(!=)), Array{Float64, 1}, Nothing})
precompile(Tuple{typeof(Base.:(!=)), Array{Float64, 2}, Nothing})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 2}, Function, Int64})
precompile(Tuple{Type{NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :smooth_alpha, :slew_um1, :ux, :uu, :slew_reg, :smooth_cstr), T} where T<:Tuple}, Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, String}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :smooth_alpha, :slew_um1, :ux, :uu, :slew_reg, :smooth_cstr), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, String}}, typeof(PMPC.make_prob), Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{PMPC.var"#7#8", Nothing})
precompile(Tuple{typeof(Base.map), PMPC.var"#7#8", Tuple{Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}}})
precompile(Tuple{Type{PMPC.OCProb{Float64}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Float64, Float64, Float64, Nothing, Float64, Int64, Int64, Int64})
precompile(Tuple{typeof(Base.setproperty!), PMPC.OCProb{Float64}, Symbol, Float64})
precompile(Tuple{typeof(Base.:(!=)), Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing})
precompile(Tuple{typeof(PMPC.set_ubounds!), PMPC.OCProb{Float64}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{Type{NamedTuple{(:slew_reg0, :slew_um1, :slew_reg), T} where T<:Tuple}, Tuple{Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:slew_reg0, :slew_um1, :slew_reg), Tuple{Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}}, typeof(PMPC.set_ctrl_slew!), PMPC.OCProb{Float64}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, PMPC.var"#106#108", Base.Dict{Any, Any}})
precompile(Tuple{Type{Base.Dict{Symbol, Any}}, Base.Generator{Base.Dict{Any, Any}, PMPC.var"#106#108"}})
precompile(Tuple{typeof(PMPC.lcone_repr_Pq), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{Type{NamedTuple{(:shift, :check), T} where T<:Tuple}, Tuple{Float64, Bool}})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{8}})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{10}})
precompile(Tuple{typeof(SparseArrays.HigherOrderFns._sparsifystructured), Float64})
precompile(Tuple{typeof(Base.:(==)), Function, Function})
precompile(Tuple{typeof(SparseArrays._iszero), Float64})
precompile(Tuple{typeof(Base.adjoint), Float64})
precompile(Tuple{typeof(Base.:(\)), Float64, Float64})
precompile(Tuple{typeof(Base.pairs), NamedTuple{(:check,), Tuple{Bool}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(), Tuple{}}, Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:check,), Tuple{Bool}}}})
precompile(Tuple{Type{LinearAlgebra.SingularException}, Int64})
precompile(Tuple{Type{SparseArrays.UMFPACK.MatrixIllConditionedException}, String})
precompile(Tuple{typeof(Base.cconvert), Type{Ptr{Int64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{Int64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.cconvert), Type{Ptr{Float64}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ptr{Float64}}, Ptr{Nothing}})
precompile(Tuple{Type{NamedTuple{(:expand_only,), T} where T<:Tuple}, Tuple{Bool}})
precompile(Tuple{typeof(Base.convert), Type{Ptr{SparseArrays.LibSuiteSparse.cholmod_dense_struct}}, Ptr{Nothing}})
precompile(Tuple{typeof(Base.abs2), Float64})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#412#threadsfor_fun#72"{PMPC.var"#412#threadsfor_fun#70#73"{Array{PMPC.OCProb{Float64}, 1}, Array{Array{Float64, 1}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{typeof(Base.getindex), Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Int64, Int64, Int64})
precompile(Tuple{typeof(Base.setindex!), Array{Float64, 1}, Float64, Int64})
precompile(Tuple{typeof(Base.:(*)), Float64, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(+)), Tuple{Array{Float64, 1}, Array{Float64, 1}}})
precompile(Tuple{typeof(Base.Broadcast.materialize!), Base.SubArray{Float64, 1, Array{Float64, 1}, Tuple{Base.UnitRange{Int64}}, true}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(Base.:(+)), Tuple{Array{Float64, 1}, Array{Float64, 1}}}})
precompile(Tuple{typeof(Base.getindex), Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Int64, Int64})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Float64, Base.Val{2}})
precompile(Tuple{typeof(Base.:(*)), Float64, Float64, Float64})
precompile(Tuple{typeof(SparseArrays.CHOLMOD.error_handler), Int32, Base.Cstring, Int32, Base.Cstring})
precompile(Tuple{typeof(Base.get!), typeof(SparseArrays.CHOLMOD.newcommon), Base.IdDict{Any, Any}, Any})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_allocate_sparse), Int64, Int64, Int64, Bool, Bool, Int64, Int64, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_check_sparse), SparseArrays.CHOLMOD.Sparse{Float64}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_symmetry), SparseArrays.CHOLMOD.Sparse{Float64}, Int64, Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(Base.getindex), Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(Base.getproperty), SparseArrays.LibSuiteSparse.cholmod_common_struct, Symbol})
precompile(Tuple{typeof(Base.setproperty!), SparseArrays.LibSuiteSparse.cholmod_common_struct, Symbol, Bool})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_analyze), SparseArrays.CHOLMOD.Sparse{Float64}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(Base.setproperty!), SparseArrays.LibSuiteSparse.cholmod_common_struct, Symbol, Int32})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_factorize_p), SparseArrays.CHOLMOD.Sparse{Float64}, Base.RefValue{Float64}, Ptr{Nothing}, Int64, SparseArrays.CHOLMOD.Factor{Float64}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{Type{SparseArrays.CHOLMOD.FactorComponent{Float64, :L}}, SparseArrays.CHOLMOD.Factor{Float64}})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_copy_factor), SparseArrays.CHOLMOD.Factor{Float64}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_factor_to_sparse), SparseArrays.CHOLMOD.Factor{Float64}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SparseArrays.halfperm!), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Base.UnitRange{Int64}, SparseArrays.var"#8#9"})
precompile(Tuple{typeof(SparseArrays._sparsevector!), Array{Int64, 1}, Array{Float64, 1}, Int64, typeof(Base.:(+))})
precompile(Tuple{typeof(Base.argtail), SparseArrays.SparseVector{Float64, Int64}, Float64, Vararg{Any}})
precompile(Tuple{typeof(Base.map), typeof(SparseArrays._makesparse), Tuple{Float64, SparseArrays.SparseVector{Float64, Int64}}})
precompile(Tuple{typeof(Base.promote_eltype), SparseArrays.SparseVector{Float64, Int64}, Float64, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_t), Base.Val{1}, Type{Float64}, SparseArrays.SparseVector{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.cat_size_shape), Tuple{Bool}, SparseArrays.SparseVector{Float64, Int64}, Float64, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_size_shape), Tuple{Bool}, Tuple{Int64}, Float64, SparseArrays.SparseVector{Float64, Int64}})
precompile(Tuple{typeof(Base.cat_similar), SparseArrays.SparseVector{Float64, Int64}, Type, Tuple{Int64}})
precompile(Tuple{typeof(Base.similar), SparseArrays.SparseVector{Float64, Int64}, Type{Float64}, Tuple{Int64}})
precompile(Tuple{typeof(Base.__cat), SparseArrays.SparseVector{Float64, Int64}, Tuple{Int64}, Tuple{Bool}, SparseArrays.SparseVector{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseVector{Float64, Int64}, Tuple{Int64}, Tuple{Bool}, Tuple{Int64}, SparseArrays.SparseVector{Float64, Int64}, Float64, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseVector{Float64, Int64}, Tuple{Int64}, Tuple{Bool}, Tuple{Int64}, Float64, SparseArrays.SparseVector{Float64, Int64}})
precompile(Tuple{typeof(SparseArrays.blockdiag), SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{Base.Threads.var"#1#2"{PMPC.var"#426#threadsfor_fun#74"{PMPC.var"#426#threadsfor_fun#71#75"{Int64, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Array{SparseArrays.SparseMatrixCSC{Float64, Int64}, 1}, Int64, Int64, Int64, Int64, Int64, Base.UnitRange{Int64}}}, Int64}})
precompile(Tuple{typeof(Base.promote_eltype), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(SparseArrays.promote_idxtype), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(PMPC.lcone_repr_Ab), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{typeof(PMPC.lcone_repr_Gla), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{typeof(Base.getindex), Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Int64})
precompile(Tuple{typeof(Base.zeros), Int64})
precompile(Tuple{typeof(Base.vcat), Array{Float64, 1}, Array{Float64, 1}, Float64})
precompile(Tuple{typeof(Base.__cat_offset!), Array{Float64, 1}, Tuple{Int64}, Tuple{Bool}, Tuple{Int64}, Array{Float64, 1}, Float64})
precompile(Tuple{typeof(Base.require_one_based_indexing), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.size), SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64})
precompile(Tuple{typeof(Base.fill), Int64, Int64})
precompile(Tuple{typeof(LinearAlgebra.promote_to_arrays), Array{Int64, 1}, Int64, Type{SparseArrays.SparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv}, SparseArrays.SparseMatrixCSC{Float64, Int64}, LinearAlgebra.UniformScaling{Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:dims,), Tuple{Base.Val{2}}}, typeof(Base.cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{Base.var"##cat#153", Base.Val{2}, typeof(Base.cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat), Base.Val{2}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Union{Number, Array{T, 1} where T, Array{T, 2} where T, LinearAlgebra.AbstractTriangular{T, A} where A<:(Array{T, 2} where T) where T, LinearAlgebra.AbstractTriangular{T, A} where A<:Union{LinearAlgebra.Adjoint{var"#s970", var"#s969"} where var"#s969"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s970", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Transpose{var"#s968", var"#s967"} where var"#s967"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s968", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv} where T, LinearAlgebra.Adjoint{var"#s970", var"#s969"} where var"#s969"<:(Array{T, 1} where T) where var"#s970", LinearAlgebra.Adjoint{var"#s970", var"#s969"} where var"#s969"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s970", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Hermitian{T, A} where A<:(Array{T, 2} where T) where T, LinearAlgebra.Hermitian{T, A} where A<:Union{LinearAlgebra.Adjoint{var"#s970", var"#s969"} where var"#s969"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s970", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Transpose{var"#s968", var"#s967"} where var"#s967"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s968", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Symmetric{T, A} where A<:(Array{T, 2} where T) where T, LinearAlgebra.Symmetric{T, A} where A<:Union{LinearAlgebra.Adjoint{var"#s970", var"#s969"} where var"#s969"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s970", LinearAlgebra.Bidiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.SymTridiagonal{T, V} where V<:AbstractArray{T, 1} where T, LinearAlgebra.Transpose{var"#s968", var"#s967"} where var"#s967"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s968", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv} where T, LinearAlgebra.Transpose{var"#s968", var"#s967"} where var"#s967"<:(Array{T, 1} where T) where var"#s968", LinearAlgebra.Transpose{var"#s968", var"#s967"} where var"#s967"<:(SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv) where var"#s968", LinearAlgebra.Tridiagonal{T, V} where V<:AbstractArray{T, 1} where T, SparseArrays.AbstractSparseMatrixCSC{Tv, Ti} where Ti<:Integer where Tv, SparseArrays.SparseVector{Tv, Ti} where Ti<:Integer where Tv}}})
precompile(Tuple{typeof(Base.argtail), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.map), typeof(SparseArrays._makesparse), Tuple{SparseArrays.SparseMatrixCSC{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.promote_eltype), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_t), Base.Val{2}, Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.cat_size_shape), Tuple{Bool, Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base._cat_size_shape), Tuple{Bool, Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.cat_similar), SparseArrays.SparseMatrixCSC{Float64, Int64}, Type, Tuple{Int64, Int64}})
precompile(Tuple{typeof(Base.similar), SparseArrays.SparseMatrixCSC{Float64, Int64}, Type{Float64}, Tuple{Int64, Int64}})
precompile(Tuple{typeof(Base.__cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool, Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool, Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool, Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.length), Array{Float64, 1}})
precompile(Tuple{Type{PMPC.ConeProblem}, Int64, Array{Int64, 1}, Int64, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{Type{NamedTuple{(:method, :solver), T} where T<:Tuple}, Tuple{String, String}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:method, :solver), Tuple{String, String}}, typeof(PMPC.smoothen_linear_inequlities), SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Float64})
precompile(Tuple{typeof(Base.argtail), SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{Any}})
precompile(Tuple{typeof(Base.map), typeof(SparseArrays._makesparse), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(SparseArrays.CHOLMOD.free!), SparseArrays.CHOLMOD.Sparse{Float64}})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_free_sparse), Base.RefValue{Ptr{SparseArrays.LibSuiteSparse.cholmod_sparse_struct}}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(SparseArrays.CHOLMOD.free!), SparseArrays.CHOLMOD.Factor{Float64}})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_free_factor), Base.RefValue{Ptr{SparseArrays.LibSuiteSparse.cholmod_factor_struct}}, Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{typeof(Base._cat_t), Base.Val{1}, Type{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.cat_size_shape), Tuple{Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base._cat_size_shape), Tuple{Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.__cat), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(Base.__cat_offset!), SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Int64, Int64}, Tuple{Bool}, Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(SparseArrays.blockdiag), SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{typeof(SparseArrays._blockdiag), Type{Float64}, Type{Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vararg{SparseArrays.SparseMatrixCSC{Float64, Int64}}})
precompile(Tuple{Type{NamedTuple{(:extra_cstr,), T} where T<:Tuple}, Tuple{Tuple{Int64, Array{Int64, 1}, Int64, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}}}})
precompile(Tuple{typeof(Base._after_colon), Base.Colon})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Tuple{Base.Colon}, typeof(Base.identity)}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Tuple{Base.Colon}, typeof(Base.identity)}, Int64, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Base.BottomRF{typeof(Base.mul_prod)}, Tuple{Base.Colon}}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{Base.BottomRF{typeof(Base.mul_prod)}, Tuple{Base.Colon}}, Int64, Int64})
precompile(Tuple{typeof(Base.prod), Tuple{Int64}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:extra_cstr,), Tuple{Tuple{Int64, Array{Int64, 1}, Int64, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}}}}, typeof(PMPC.augment_cone_problem!), PMPC.ConeProblem})
precompile(Tuple{typeof(Base.getindex), Array{Float64, 1}, Base.UnitRange{Int64}})
precompile(Tuple{typeof(Base._sum), Array{Int64, 1}, Base.Colon})
precompile(Tuple{typeof(Base.vcat), Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.setproperty!), PMPC.ConeProblem, Symbol, Array{Float64, 1}})
precompile(Tuple{typeof(Base.convert), Type{Union{Nothing, AbstractArray{Float64, 1}}}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.copy), Array{Float64, 1}})
precompile(Tuple{typeof(Base.convert), Type{AbstractArray{Float64, 1}}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.iterate), Array{Tuple, 1}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:verbose,), Tuple{Bool}}, typeof(PMPC.ECOS_solve), PMPC.ConeProblem})
precompile(Tuple{typeof(Base._array_for), Type{Int64}, Base.HasShape{1}, Tuple{Base.OneTo{Int64}}})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Int64, 1}, Int64, Base.Generator{Array{Symbol, 1}, PMPC.var"#55#56"{PMPC.ConeProblem}}, Int64})
precompile(Tuple{typeof(Base.setindex_widen_up_to), Array{Int64, 1}, Array{Int64, 1}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Any, 1}, Base.Generator{Array{Symbol, 1}, PMPC.var"#55#56"{PMPC.ConeProblem}}, Int64, Int64})
precompile(Tuple{typeof(Base.:(!=)), SparseArrays.SparseMatrixCSC{Float64, Int64}, Nothing})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Int64, 1}, Int64, Base.Generator{Array{Symbol, 1}, PMPC.var"#50#52"{PMPC.ConeProblem}}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Any, 1}, Base.Generator{Array{Symbol, 1}, PMPC.var"#50#52"{PMPC.ConeProblem}}, Int64, Int64})
precompile(Tuple{typeof(Base.copy), SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.size), SparseArrays.SparseMatrixCSC{Float64, Int64}})
precompile(Tuple{typeof(Base.sum), Array{Int64, 1}})
precompile(Tuple{typeof(Base.axes), SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64})
precompile(Tuple{typeof(Base.maybeview), SparseArrays.SparseMatrixCSC{Float64, Int64}, Base.UnitRange{Int64}, Function})
precompile(Tuple{typeof(Base.getindex), SparseArrays.SparseMatrixCSC{Float64, Int64}, Base.UnitRange{Int64}, Base.Colon})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{SparseArrays.HigherOrderFns.SparseMatStyle, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(*)), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64}})
precompile(Tuple{typeof(Base.Broadcast.materialize!), Base.SubArray{Float64, 2, SparseArrays.SparseMatrixCSC{Float64, Int64}, Tuple{Base.UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{SparseArrays.HigherOrderFns.SparseMatStyle, Nothing, typeof(Base.:(*)), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64}}})
precompile(Tuple{typeof(Base.axes), Array{Float64, 1}, Int64})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Base.AbstractUnitRange{Int64}, 1}}})
precompile(Tuple{typeof(Core.Compiler.eltype), Type{Array{Base.Slice{Base.OneTo{Int64}}, 1}}})
precompile(Tuple{typeof(Base.maybeview), Array{Float64, 1}, Base.UnitRange{Int64}, Function})
precompile(Tuple{typeof(Base.getindex), Array{Float64, 1}, Base.UnitRange{Int64}, Function})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{Float64, 2}, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(*)), Tuple{Array{Float64, 2}, Int64}})
precompile(Tuple{typeof(Base.Broadcast.materialize!), Base.SubArray{Float64, 2, Array{Float64, 2}, Tuple{Base.UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{2}, Nothing, typeof(Base.:(*)), Tuple{Array{Float64, 2}, Int64}}})
precompile(Tuple{typeof(Base.getproperty), SparseArrays.SparseMatrixCSC{Float64, Int64}, Symbol})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{Int64, 1}, Int64})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(Base.:(-)), Tuple{Array{Int64, 1}, Int64}})
precompile(Tuple{typeof(Base.Broadcast.materialize), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(Base.:(-)), Tuple{Array{Int64, 1}, Int64}}})
precompile(Tuple{typeof(ECOS.ECOS_setup), Int64, Int64, Int64, Int64, Int64, Array{Int64, 1}, Int64, Array{Float64, 1}, Array{Int64, 1}, Array{Int64, 1}, Array{Float64, 1}, Array{Int64, 1}, Array{Int64, 1}, Array{Float64, 1}, Array{Float64, 1}, Array{Float64, 1}})
precompile(Tuple{Type{ECOS.settings}, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Int64, Int64, Int64, Float64, Float64})
precompile(Tuple{typeof(Base.getproperty), PMPC.ECOS_result, Symbol})
precompile(Tuple{typeof(Base.lastindex), Array{Float64, 1}})
precompile(Tuple{typeof(PMPC.split_lqp_vars), Array{PMPC.OCProb{Float64}, 1}, Int64, Array{Float64, 1}})
precompile(Tuple{Type{Pair{A, B} where B where A}, Symbol, Array{Float64, 1}})
precompile(Tuple{Type{Base.Dict{Symbol, Any}}, Pair{Symbol, Float64}, Vararg{Pair{A, B} where B where A}})
precompile(Tuple{typeof(PyCall.pyreturn), Tuple{Array{Float64, 3}, Array{Float64, 3}, Base.Dict{Symbol, Any}}})
precompile(Tuple{typeof(Base.similar), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(getfield), Tuple{Base.Broadcast.Extruded{Array{LinearAlgebra.BLAS.LBTLibraryInfo, 1}, Tuple{Bool}, Tuple{Int64}}, Base.RefValue{Symbol}}}, Type{String}})
precompile(Tuple{typeof(Base.Broadcast.copyto_nonleaf!), Array{String, 1}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(getfield), Tuple{Base.Broadcast.Extruded{Array{LinearAlgebra.BLAS.LBTLibraryInfo, 1}, Tuple{Bool}, Tuple{Int64}}, Base.RefValue{Symbol}}}, Base.OneTo{Int64}, Int64, Int64})
precompile(Tuple{typeof(Base.any), Function, Array{String, 1}})
precompile(Tuple{typeof(Base._any), Base.Fix2{typeof(Base.contains), String}, Array{String, 1}, Base.Colon})
precompile(Tuple{Type{PyCall.PyObject}, Nothing})
precompile(Tuple{typeof(SparseArrays.LibSuiteSparse.cholmod_l_finish), Base.RefValue{SparseArrays.LibSuiteSparse.cholmod_common_struct}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), T} where T<:Tuple}, Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}})
precompile(Tuple{typeof(Base.isempty), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{Base.var"##invokelatest#2", Base.Pairs{Symbol, Any, NTuple{8, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}, typeof(PMPC.lcone_solve), Array{Float64, 2}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}})
precompile(Tuple{Type{NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :slew_um1, :ux, :uu, :slew_reg), T} where T<:Tuple}, Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:lu, :reg_u, :slew_reg0, :lx, :reg_x, :solver, :solver_state, :slew_um1, :ux, :uu, :slew_reg), Tuple{Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64, Float64, Nothing, Float64, String, Nothing, Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Nothing, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Float64}}, typeof(PMPC.make_prob), Base.SubArray{Float64, 1, Array{Float64, 2}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 3, Array{Float64, 4}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}, Base.SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}, PyCall.PyDict{Symbol, PyCall.PyObject, true}})
precompile(Tuple{typeof(Base.collect), Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}}})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Tuple{Symbol, Float64}, 1}, Tuple{Symbol, Float64}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}}, PyCall.PyDict_Iterator})
precompile(Tuple{typeof(Base.collect_to!), Array{Tuple{Symbol, Any}, 1}, Base.Generator{PyCall.PyDict{Symbol, PyCall.PyObject, true}, PyCall.var"#57#58"{typeof(PMPC.lqp_solve)}}, Int64, PyCall.PyDict_Iterator})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.Silent, String})
precompile(Tuple{typeof(MutableArithmetics._combine_styles), Type})
precompile(Tuple{typeof(MutableArithmetics._combine_styles), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_broadcast), typeof(MutableArithmetics.sub_mul), Type, Type})
precompile(Tuple{typeof(Base.Broadcast.combine_eltypes), Function, Tuple{DataType, DataType}})
precompile(Tuple{typeof(Base.eltype), Type})
precompile(Tuple{typeof(MutableArithmetics.broadcast_mutability), Type, Function, Type, Type})
precompile(Tuple{typeof(Base.Broadcast.broadcastable), Float64})
precompile(Tuple{typeof(Base.getindex), Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, Symbol})
precompile(Tuple{typeof(MutableArithmetics._instantiate_zero), Type{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}}})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(Base.:(-)), Type{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}}, Type{Nothing}})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(Base.:(-)), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation_fallback), typeof(MutableArithmetics.sub_mul), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.promote_operation), typeof(MutableArithmetics.sub_mul), Type, Type})
precompile(Tuple{typeof(MutableArithmetics.mutability), Type, Function, Type, Type})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), typeof(JuMP.value), Nothing})
precompile(Tuple{typeof(Base.convert), Type{Ptr{OSQP.Workspace}}, Ptr{Nothing}})
precompile(Tuple{typeof(SparseArrays._iszero), Nothing})
precompile(Tuple{typeof(Base.getindex), Base.UnitRange{Int64}, Int64})
precompile(Tuple{typeof(Base.lastindex), Base.UnitRange{Int64}})
precompile(Tuple{typeof(Base.promote_rule), Type{Nothing}, Type})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{5}})
precompile(Tuple{typeof(Base.literal_pow), typeof(Base.:(^)), Int64, Base.Val{7}})
precompile(Tuple{Type{Random.Sampler{E} where E}, Random.TaskLocalRNG, Base.UnitRange{Int64}, Base.Val{1}})
precompile(Tuple{typeof(Base.:(-)), UInt64})
precompile(Tuple{typeof(Base.mod), UInt64, UInt64})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}, typeof(PMPC.lqp_solve), Array{Float64, 2}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 3}, Array{Float64, 3}})
precompile(Tuple{typeof(Base.empty), Base.Dict{Any, Any}, Type{Symbol}, Type{Float64}})
precompile(Tuple{typeof(Base.setindex!), Base.Dict{Symbol, Float64}, Float64, Symbol})
precompile(Tuple{typeof(Base.grow_to!), Base.Dict{Symbol, Float64}, Base.Generator{Base.Pairs{Symbol, Any, NTuple{8, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}}, PMPC.var"#101#102"}, Int64})
precompile(Tuple{typeof(Base.empty), Base.Dict{Symbol, Float64}, Type{Symbol}, Type{Any}})
precompile(Tuple{typeof(Base.merge!), Base.Dict{Symbol, Any}, Base.Dict{Symbol, Float64}})
precompile(Tuple{typeof(Base.grow_to!), Base.Dict{Symbol, Any}, Base.Generator{Base.Pairs{Symbol, Any, NTuple{8, Symbol}, NamedTuple{(:reg_x, :reg_u, :lx, :ux, :lu, :uu, :solver, :solver_state), Tuple{Float64, Float64, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, String, Nothing}}}, PMPC.var"#101#102"}, Int64})
precompile(Tuple{typeof(Base.get), Base.Dict{Symbol, Any}, Symbol, Bool})
precompile(Tuple{typeof(Base.get), Base.Dict{Symbol, Any}, Symbol, Int64})
precompile(Tuple{typeof(Base.get), Base.Dict{Symbol, Any}, Symbol, Nothing})
precompile(Tuple{typeof(PMPC.lqp_repr_Pq), Array{PMPC.OCProb{Float64}, 1}, Int64})
precompile(Tuple{Type{PMPC.OSQPSolver{Float64}}, Vararg{Nothing, 13}})
precompile(Tuple{typeof(Base.setproperty!), PMPC.OSQPSolver{Float64}, Symbol, Array{Float64, 1}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :lu, :uu, :reg_u, :solver, :solver_state, :lx, :ux), T} where T<:Tuple}, Tuple{Float64, Array{Float64, 3}, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:reg_x, :lu, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}, typeof(PMPC.solve_qp!), PMPC.OSQPSolver{Float64}})
precompile(Tuple{Type{NamedTuple{(:P, :q, :A, :l, :u), T} where T<:Tuple}, Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(:P, :q, :A, :l, :u), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}}}, Base.Dict{Symbol, Any}})
precompile(Tuple{Type{NamedTuple{(:reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), T} where T<:Tuple}, Tuple{Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}})
precompile(Tuple{typeof(Base._nt_names), Type{NamedTuple{(:reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}}})
precompile(Tuple{typeof(Base.merge), NamedTuple{(:P, :q, :A, :l, :u), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}}}, NamedTuple{(:reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}})
precompile(Tuple{typeof(Base.Broadcast._getindex), Tuple{Float64}, Int64})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:P, :q, :A, :l, :u, :reg_x, :lu, :verbose, :uu, :reg_u, :solver, :solver_state, :lx, :ux), Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{Float64, 1}, Array{Float64, 1}, Float64, Array{Float64, 3}, Bool, Array{Float64, 3}, Float64, String, Nothing, Array{Float64, 3}, Array{Float64, 3}}}, typeof(OSQP.setup!), OSQP.Model})
precompile(Tuple{typeof(Base._array_for), Type{Float64}, Base.HasLength, Int64})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Float64, 1}, Float64, Base.Generator{NTuple{22, Symbol}, OSQP.var"#7#8"{Base.Dict{Symbol, Any}, OSQP.Settings}}, Int64})
precompile(Tuple{typeof(Base.setindex_widen_up_to), Array{Float64, 1}, Int64, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Real, 1}, Base.Generator{NTuple{22, Symbol}, OSQP.var"#7#8"{Base.Dict{Symbol, Any}, OSQP.Settings}}, Int64, Int64})
precompile(Tuple{typeof(Base.convert), Type{Int64}, Bool})
precompile(Tuple{Type{OSQP.Settings}, Float64, Float64, Int64, Int64, Int64, Float64, Float64, Int64, Float64, Float64, Float64, Float64, Float64, Int32, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Float64})
precompile(Tuple{Type{Ref{T} where T}, OSQP.Settings})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:verbose,), Tuple{Bool}}, typeof(PMPC.JuMP_solve), PMPC.ConeProblem})
precompile(Tuple{typeof(Base.collect_to_with_first!), Array{Int64, 1}, Int64, Base.Generator{Array{Symbol, 1}, PMPC.var"#61#65"{PMPC.ConeProblem}}, Int64})
precompile(Tuple{typeof(Base.collect_to!), Array{Any, 1}, Base.Generator{Array{Symbol, 1}, PMPC.var"#61#65"{PMPC.ConeProblem}}, Int64, Int64})
precompile(Tuple{typeof(OSQP.clean!), OSQP.Model})
precompile(Tuple{MathOptInterface.var"##instantiate#25", Type{Float64}, Nothing, typeof(MathOptInterface.instantiate), Any})
precompile(Tuple{typeof(Mosek.msk_stream_callback_wrapper), Ptr{Nothing}, Ptr{UInt8}})
precompile(Tuple{typeof(Mosek.msk_info_callback_wrapper), Ptr{Nothing}, Ptr{Nothing}, Int32, Ptr{Float64}, Ptr{Int32}, Ptr{Int64}})
precompile(Tuple{typeof(Mosek.Optimizer)})
precompile(Tuple{typeof(MathOptInterface.is_empty), MosekTools.Optimizer})
precompile(Tuple{typeof(MathOptInterface.set), MosekTools.Optimizer, MathOptInterface.RawOptimizerAttribute, Bool})
precompile(Tuple{typeof(MathOptInterface.supports_incremental_interface), MosekTools.Optimizer})
precompile(Tuple{typeof(MathOptInterface.Bridges.full_bridge_optimizer), MosekTools.Optimizer, Type{Float64}})
precompile(Tuple{typeof(MathOptInterface.Bridges.add_bridge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}})
precompile(Tuple{Base.Fix2{typeof(Base.isequal), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}}, Type})
precompile(Tuple{Type{MathOptInterface.RawOptimizerAttribute}, String})
precompile(Tuple{Type{MathOptInterface.SetAttributeNotAllowed{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.TimeLimitSec, String})
precompile(Tuple{Type{MathOptInterface.Utilities.CachingOptimizer{O, M} where M<:MathOptInterface.ModelLike where O}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}})
precompile(Tuple{Type{Base.Generator{I, F} where F where I}, JuMP.Containers.var"#80#81"{PMPC.var"#64#68"}, JuMP.Containers.VectorizedProductIterator{Tuple{Base.OneTo{Int64}}}})
precompile(Tuple{typeof(Base.collect), Base.Generator{JuMP.Containers.VectorizedProductIterator{Tuple{Base.OneTo{Int64}}}, JuMP.Containers.var"#80#81"{PMPC.var"#64#68"}}})
precompile(Tuple{Type{MosekTools.MatrixIndex}, Int64, Int64, Int64})
precompile(Tuple{typeof(Base.convert), Type{Mosek.Boundkey}, Mosek.Boundkey})
precompile(Tuple{typeof(Base.Broadcast._getindex), Tuple{Int32}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{String, String}, Int64})
precompile(Tuple{typeof(Base.indexed_iterate), Tuple{String, String}, Int64, Int64})
precompile(Tuple{typeof(JuMP._moi_add_variable), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, JuMP.Model, JuMP.ScalarVariable{Float64, Float64, Float64, Float64}, String})
precompile(Tuple{typeof(MathOptInterface.set), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VariableName, MathOptInterface.VariableIndex, String})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.add_mul), MutableArithmetics.Zero, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{JuMP.VariableRef, 1}})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.sub_mul), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}})
precompile(Tuple{typeof(Base.copyto!), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}}, MutableArithmetics.var"#f#1"{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(MutableArithmetics.sub_mul), Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}}, Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}})
precompile(Tuple{typeof(Base.Broadcast._broadcast_getindex_evalf), MutableArithmetics.var"#f#1"{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(MutableArithmetics.sub_mul), Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}}, JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, Float64})
precompile(Tuple{MutableArithmetics.var"#f#1"{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, typeof(MutableArithmetics.sub_mul), Tuple{Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}}}}, JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, Float64})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Tuple{DataType, DataType}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(MutableArithmetics._shape), Tuple{Tuple{DataType, DataType}}})
precompile(Tuple{typeof(Base.Broadcast.instantiate), Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(MutableArithmetics._shape), Tuple{Tuple{DataType, DataType}}}})
precompile(Tuple{typeof(MutableArithmetics.broadcast!!), typeof(MutableArithmetics.sub_mul), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Int64})
precompile(Tuple{typeof(JuMP._functionize), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}})
precompile(Tuple{typeof(JuMP._desparsify), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}})
precompile(Tuple{Type{Base.RefValue{T} where T}, JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, JuMP.Model, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}}, String})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(JuMP.add_constraint), Tuple{Base.RefValue{JuMP.Model}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}}, Base.RefValue{String}}})
precompile(Tuple{typeof(Base.Broadcast.materialize), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.add_constraint), Tuple{Base.RefValue{JuMP.Model}, Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.build_constraint), Tuple{Base.RefValue{JuMP.var"#_error#80"{Tuple{Symbol, Expr}, Symbol, LineNumberNode}}, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Base.RefValue{JuMP.Zeros}}}, Base.RefValue{String}}}})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.sub_mul), MutableArithmetics.Zero, SparseArrays.SparseMatrixCSC{Float64, Int64}, Array{JuMP.VariableRef, 1}})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.add_mul), Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, Array{Float64, 1}})
precompile(Tuple{typeof(JuMP.build_constraint), Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(JuMP.add_constraint), JuMP.Model, JuMP.VectorConstraint{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, MathOptInterface.Nonnegatives, JuMP.VectorShape}, String})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(OrderedCollections.hashindex), Tuple{DataType, DataType}, Int64})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.ScalarAffineFunction{Float64}}, Type{MathOptInterface.LessThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonpositives}}})
precompile(Tuple{typeof(Base.convert), Type{Tuple{Type}}, Tuple{DataType}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.VariableIndex, MathOptInterface.LessThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VariableIndex}, Type{MathOptInterface.LessThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, MathOptInterface.Nonpositives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ZerosBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.FreeBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.VariableIndex, MathOptInterface.GreaterThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VariableIndex}, Type{MathOptInterface.GreaterThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, MathOptInterface.Nonnegatives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorOfVariables}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ZerosBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.FreeBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.NonposToNonnegBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.VectorizeBridge{Float64, S} where S}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.SOCtoRSOCBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoSOCBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoPSDBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ParameterToEqualToBridge{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.VectorizeBridge{Float64, S} where S}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.SOCtoRSOCBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoSOCBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.RSOCtoPSDBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.HermitianToSymmetricPSDBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Variable.supports_constrained_variable), Type{MathOptInterface.Bridges.Variable.ParameterToEqualToBridge{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MosekTools.ScaledPSDConeBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToIntervalBridge{Float64, F} where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, F, G} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractScalarFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonnegToNonposBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.ScalarAffineFunction{Float64}}, Type{MathOptInterface.EqualTo{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Zeros, MathOptInterface.Nonnegatives, MathOptInterface.Nonpositives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Zeros}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonpositives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NonposToNonnegBridge{Float64, F, G} where G<:MathOptInterface.AbstractVectorFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.Bridges.node), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type{MathOptInterface.ScalarAffineFunction{Float64}}, Type{MathOptInterface.GreaterThan{Float64}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorizeBridge{Float64, F, S, G} where G where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, F, S} where S where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges._edge), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Int64, Type{MathOptInterface.Bridges.Constraint.VectorSlackBridge{Float64, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.VectorFunctionizeBridge{Float64, S} where S}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitHyperRectangleBridge{Float64, G, F} where F where G}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitIntervalBridge{Float64, F, S, LS, US} where US<:MathOptInterface.AbstractSet where LS<:MathOptInterface.AbstractSet where S<:MathOptInterface.AbstractSet where F<:MathOptInterface.AbstractFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexEqualToBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SplitComplexZerosBridge{Float64, F, G} where G<:Union{MathOptInterface.ScalarAffineFunction{Base.Complex{Float64}}, MathOptInterface.ScalarQuadraticFunction{Base.Complex{Float64}}, MathOptInterface.VectorAffineFunction{Base.Complex{Float64}}, MathOptInterface.VectorQuadraticFunction{Base.Complex{Float64}}} where F<:Union{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorQuadraticFunction{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.QuadtoSOCBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormInfinityBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormOneBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeantoRelEntrBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.GeoMeanToPowerBridge{Float64, F} where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RelativeEntropyBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormSpectralBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.NormNuclearBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.HermitianToSymmetricPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SquareBridge{Float64, F, G, TT, ST} where ST<:Union{MathOptInterface.LogDetConeSquare, MathOptInterface.RootDetConeSquare, MathOptInterface.AbstractSymmetricMatrixSetSquare} where TT<:Union{MathOptInterface.LogDetConeTriangle, MathOptInterface.RootDetConeTriangle, MathOptInterface.AbstractSymmetricMatrixSetTriangle} where G<:MathOptInterface.AbstractScalarFunction where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.LogDetBridge{Float64, F, G, H, I} where I where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RootDetBridge{Float64, F, G, H} where H where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SOCtoRSOCBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.RSOCtoPSDBridge{Float64, F, G} where G where F}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorActiveOnFalseBridge{Float64, F, S} where S<:MathOptInterface.AbstractScalarSet where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSOS1Bridge{Float64, S} where S<:MathOptInterface.AbstractScalarSet}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.LessToGreaterBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.LessThan{Float64}, MathOptInterface.GreaterThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.IndicatorSetMapBridge{Float64, MathOptInterface.Bridges.Constraint.GreaterToLessBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.GreaterThan{Float64}, MathOptInterface.LessThan{Float64}, A} where A}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.SemiToBinaryBridge{Float64, S} where S<:Union{MathOptInterface.Semicontinuous{Float64}, MathOptInterface.Semiinteger{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ZeroOneBridge{Float64}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.AllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedAllDifferentToCountDistinctBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.BinPackingToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CircuitToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountAtLeastToCountBelongsBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountBelongsToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.ReifiedCountDistinctToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.CountGreaterThanToMILPBridge{Float64, F} where F<:Union{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.VectorOfVariables}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.supports_constraint), Type{MathOptInterface.Bridges.Constraint.TableToMILPBridge{Float64, F} where F<:MathOptInterface.AbstractVectorFunction}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{Type{MathOptInterface.SecondOrderCone}, Int64})
precompile(Tuple{typeof(JuMP.build_constraint), Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, MathOptInterface.SecondOrderCone})
precompile(Tuple{typeof(JuMP.add_constraint), JuMP.Model, JuMP.VectorConstraint{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, MathOptInterface.SecondOrderCone, JuMP.VectorShape}, String})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone})
precompile(Tuple{typeof(JuMP.build_constraint), Function, Array{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, 1}, MathOptInterface.ExponentialCone})
precompile(Tuple{typeof(JuMP.add_constraint), JuMP.Model, JuMP.VectorConstraint{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}, MathOptInterface.ExponentialCone, JuMP.VectorShape}, String})
precompile(Tuple{typeof(Base.first), Base.StepRange{Int64, Int64}})
precompile(Tuple{typeof(Base.step_hp), Base.StepRange{Int64, Int64}})
precompile(Tuple{typeof(Base.step), Base.StepRange{Int64, Int64}})
precompile(Tuple{typeof(Base.last), Base.StepRange{Int64, Int64}})
precompile(Tuple{typeof(JuMP._moi_add_constraint), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone})
precompile(Tuple{typeof(Base.adjoint), Array{Float64, 1}})
precompile(Tuple{typeof(MutableArithmetics.operate!!), typeof(MutableArithmetics.add_mul), MutableArithmetics.Zero, LinearAlgebra.Adjoint{Float64, Array{Float64, 1}}, Array{JuMP.VariableRef, 1}})
precompile(Tuple{typeof(JuMP.set_objective), JuMP.Model, MathOptInterface.OptimizationSense, JuMP.GenericAffExpr{Float64, JuMP.VariableRef}})
precompile(Tuple{typeof(MathOptInterface.set), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ObjectiveSense, MathOptInterface.OptimizationSense})
precompile(Tuple{typeof(MathOptInterface.supports), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ObjectiveFunction{MathOptInterface.ScalarAffineFunction{Float64}}})
precompile(Tuple{typeof(MathOptInterface.set), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.ObjectiveFunction{MathOptInterface.ScalarAffineFunction{Float64}}, MathOptInterface.ScalarAffineFunction{Float64}})
precompile(Tuple{Type{MathOptInterface.UnsupportedAttribute{AttrType} where AttrType<:Union{MathOptInterface.AbstractConstraintAttribute, MathOptInterface.AbstractModelAttribute, MathOptInterface.AbstractOptimizerAttribute, MathOptInterface.AbstractVariableAttribute}}, MathOptInterface.VariableName, String})
precompile(Tuple{typeof(Base.convert), Type{Int32}, Mosek.Onoffkey})
precompile(Tuple{Type{NamedTuple{(:by, :rev), T} where T<:Tuple}, Tuple{MosekTools.var"#16#17", Bool}})
precompile(Tuple{typeof(Base._nt_names), Type{NamedTuple{(:scratch,), Tuple{Array{MosekTools.MosekSolution, 1}}}}})
precompile(Tuple{typeof(MathOptInterface.optimize!), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}})
precompile(Tuple{Base.Fix2{typeof(MathOptInterface.Utilities.final_touch), Nothing}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}})
precompile(Tuple{MathOptInterface.Utilities.var"#166#167"{MathOptInterface.ListOfConstraintTypesPresent}, MathOptInterface.Utilities.ModelScalarConstraints{Float64, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ZeroOne}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Integer}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Interval{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Semicontinuous{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Semiinteger{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Parameter{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.ModelScalarConstraints{Float64, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.ZeroOne}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Integer}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Interval{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Semicontinuous{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Semiinteger{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.Parameter{Float64}}}, MathOptInterface.ListOfConstraintTypesPresent})
precompile(Tuple{MathOptInterface.Utilities.var"#166#167"{MathOptInterface.ListOfConstraintTypesPresent}, MathOptInterface.Utilities.ModelVectorConstraints{Float64, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Reals}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Zeros}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonpositives}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Complements}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormInfinityCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormOneCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RotatedSecondOrderCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.GeometricMeanCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.DualExponentialCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RelativeEntropyCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormSpectralCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormNuclearCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.PositiveSemidefiniteConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.PositiveSemidefiniteConeSquare}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.HermitianPositiveSemidefiniteConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RootDetConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RootDetConeSquare}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.LogDetConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.LogDetConeSquare}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.AllDifferent}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountDistinct}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountBelongs}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountAtLeast}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountGreaterThan}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Circuit}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Cumulative}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Path}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.PowerCone{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.DualPowerCone{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SOS1{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SOS2{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Indicator{MathOptInterface.ActivationCondition(0x00000001), MathOptInterface.LessThan{Float64}}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Indicator{MathOptInterface.ActivationCondition(0x00000000), MathOptInterface.LessThan{Float64}}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Table{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.BinPacking{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.HyperRectangle{Float64}}}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.ModelVectorConstraints{Float64, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Reals}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Zeros}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonpositives}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Complements}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormInfinityCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormOneCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RotatedSecondOrderCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.GeometricMeanCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.DualExponentialCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RelativeEntropyCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormSpectralCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.NormNuclearCone}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.PositiveSemidefiniteConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.PositiveSemidefiniteConeSquare}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.HermitianPositiveSemidefiniteConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RootDetConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.RootDetConeSquare}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.LogDetConeTriangle}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.LogDetConeSquare}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.AllDifferent}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountDistinct}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountBelongs}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountAtLeast}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.CountGreaterThan}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Circuit}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Cumulative}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Path}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.PowerCone{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.DualPowerCone{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SOS1{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SOS2{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Indicator{MathOptInterface.ActivationCondition(0x00000001), MathOptInterface.LessThan{Float64}}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Indicator{MathOptInterface.ActivationCondition(0x00000000), MathOptInterface.LessThan{Float64}}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Table{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.BinPacking{Float64}}, MathOptInterface.Utilities.VectorOfConstraints{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.HyperRectangle{Float64}}}, MathOptInterface.ListOfConstraintTypesPresent})
precompile(Tuple{typeof(MathOptInterface.supports), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.ObjectiveSense})
precompile(Tuple{typeof(MathOptInterface.Utilities._pass_attribute), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, MathOptInterface.ObjectiveSense})
precompile(Tuple{typeof(MathOptInterface.Utilities._pass_attribute), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, MathOptInterface.ObjectiveFunction{MathOptInterface.ScalarAffineFunction{Float64}}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MosekTools.Optimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, 1}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MosekTools.Optimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}, 1}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.ListOfConstraintIndices{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MosekTools.Optimizer, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}, 1}})
precompile(Tuple{typeof(MathOptInterface.Utilities._copy_constraints), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}, 1}})
precompile(Tuple{typeof(Base.setindex!), Base.Dict{Any, Type}, Type, Tuple{DataType, DataType}})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.concrete_bridge_type), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}, Type{MathOptInterface.VectorAffineFunction{Float64}}, Type{MathOptInterface.Nonnegatives}})
precompile(Tuple{typeof(MathOptInterface.Bridges.add_bridged_constraint), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Type, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.bridge_constraint), Type{MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}}, MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(MathOptInterface.Bridges.Constraint.add_key_for_bridge), MathOptInterface.Bridges.Constraint.Map, MathOptInterface.Bridges.Constraint.ScalarizeBridge{Float64, MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64}}, MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, 1}})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.Nonnegatives}, 1}})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.SecondOrderCone}, 1}})
precompile(Tuple{typeof(MathOptInterface.Utilities.pass_attributes), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}, MathOptInterface.Utilities.IndexMap, Array{MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64}, MathOptInterface.ExponentialCone}, 1}})
precompile(Tuple{typeof(Base.cconvert), Type, Base.RefValue{Int32}})
precompile(Tuple{typeof(Base.convert), Type{Ref{Int32}}, Base.RefValue{Int32}})
precompile(Tuple{typeof(Base.unsafe_convert), Type{Ref{Int32}}, Base.RefValue{Int32}})
precompile(Tuple{typeof(Base.getindex), Base.RefValue{Int32}})
precompile(Tuple{Type{Array{Int32, 1}}, UndefInitializer, Int32})
precompile(Tuple{typeof(Base.disable_sigint), Mosek.var"#376#379"{Mosek.Task, Mosek.Soltype, Array{Int32, 1}}})
precompile(Tuple{typeof(Base._array_for), Type{Mosek.Stakey}, Array{Int32, 1}, Base.HasShape{1}})
precompile(Tuple{Type{Base.LinearIndices{N, R} where R<:Tuple{Vararg{Base.AbstractUnitRange{Int64}, N}} where N}, Array{Mosek.Stakey, 1}})
precompile(Tuple{Type{Mosek.Stakey}, Int32})
precompile(Tuple{typeof(Base.setindex!), Array{Mosek.Stakey, 1}, Mosek.Stakey, Int64})
precompile(Tuple{typeof(Base.disable_sigint), Mosek.var"#370#373"{Mosek.Task, Mosek.Soltype, Array{Int32, 1}}})
precompile(Tuple{typeof(Base.Broadcast.broadcasted), Function, Array{JuMP.VariableRef, 1}})
precompile(Tuple{Type{Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Axes, F, Args} where Args<:Tuple where F where Axes}, typeof(JuMP.value), Tuple{Array{JuMP.VariableRef, 1}}})
precompile(Tuple{typeof(Base.Broadcast.materialize), Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(JuMP.value), Tuple{Array{JuMP.VariableRef, 1}}}})
precompile(Tuple{typeof(JuMP._moi_get_result), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VariablePrimal, Vararg{Any}})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.Utilities.UniversalFallback{MathOptInterface.Utilities.GenericModel{Float64, MathOptInterface.Utilities.ObjectiveContainer{Float64}, MathOptInterface.Utilities.VariablesContainer{Float64}, MathOptInterface.Utilities.ModelFunctionConstraints{Float64}}}}, MathOptInterface.VariablePrimal, MathOptInterface.VariableIndex})
precompile(Tuple{typeof(MathOptInterface.get), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, MathOptInterface.VariablePrimal, MathOptInterface.VariableIndex})
precompile(Tuple{typeof(MathOptInterface.Bridges.unbridged_function), MathOptInterface.Bridges.LazyBridgeOptimizer{MosekTools.Optimizer}, Float64})
precompile(Tuple{typeof(MathOptInterface.Utilities.map_indices), MathOptInterface.Utilities.IndexMap, MathOptInterface.VariablePrimal, Float64})
precompile(Tuple{Type{NamedTuple{(:x,), T} where T<:Tuple}, Tuple{Array{Float64, 1}}})
precompile(Tuple{typeof(Base.getproperty), NamedTuple{(:x,), Tuple{Array{Float64, 1}}}, Symbol})
precompile(Tuple{typeof(Mosek.deletetask), Mosek.Task})
#precompile(Tuple{typeof(Base.CoreLogging.shouldlog), Logging.ConsoleLogger, Base.CoreLogging.LogLevel, Module, Symbol, Symbol})
precompile(Tuple{Type{NamedTuple{(:exception,), T} where T<:Tuple}, Tuple{Tuple{Base.EOFError, Array{Union{Ptr{Nothing}, Base.InterpreterIP}, 1}}}})
precompile(Tuple{typeof(Core.kwcall), NamedTuple{(:exception,), Tuple{Tuple{Base.EOFError, Array{Union{Ptr{Nothing}, Base.InterpreterIP}, 1}}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})
precompile(Tuple{Base.var"##invokelatest#2", Base.Pairs{Symbol, Tuple{Base.EOFError, Array{Union{Ptr{Nothing}, Base.InterpreterIP}, 1}}, Tuple{Symbol}, NamedTuple{(:exception,), Tuple{Tuple{Base.EOFError, Array{Union{Ptr{Nothing}, Base.InterpreterIP}, 1}}}}}, typeof(Base.invokelatest), Any, Any, Vararg{Any}})





